<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="–õ–∞–±–æ—Ä–∞—Ç–æ—Ä–Ω–∞ —Ä–æ–±–æ—Ç–∞ ‚Ññ4: –ê–¥–∞–ø—Ç–∏–≤–Ω—ñ LSB –º–µ—Ç–æ–¥–∏ - Edge-based embedding, PVD –º–µ—Ç–æ–¥">
    <meta name="keywords" content="—Å—Ç–µ–≥–∞–Ω–æ–≥—Ä–∞—Ñ—ñ—è, –∞–¥–∞–ø—Ç–∏–≤–Ω—ñ –º–µ—Ç–æ–¥–∏, Edge-based LSB, PVD, Pixel Value Differencing">
    <title>–õ–∞–±–æ—Ä–∞—Ç–æ—Ä–Ω–∞ ‚Ññ4: –ê–¥–∞–ø—Ç–∏–≤–Ω—ñ LSB –º–µ—Ç–æ–¥–∏ | –û—Å–Ω–æ–≤–∏ —Å—Ç–µ–≥–∞–Ω–æ–≥—Ä–∞—Ñ—ñ—ó</title>


    <link rel="stylesheet" href="../assets/css/base.css">
    <link rel="stylesheet" href="../assets/css/lab-universal.css">

    <!-- Highlight.js –¥–ª—è –ø—ñ–¥—Å–≤—ñ—Ç–∫–∏ –∫–æ–¥—É -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
</head>
<body>

<!-- Header -->
<header class="lab-header">
    <div class="container">
        <nav class="breadcrumb">
            <a href="../../index.html">–ì–æ–ª–æ–≤–Ω–∞</a>
            <span class="separator">/</span>
            <a href="../index.html">–õ–∞–±–æ—Ä–∞—Ç–æ—Ä–Ω—ñ</a>
            <span class="separator">/</span>
            <span class="current">–õ–∞–±–æ—Ä–∞—Ç–æ—Ä–Ω–∞ ‚Ññ4</span>
        </nav>
        <h1>üî¨ –õ–∞–±–æ—Ä–∞—Ç–æ—Ä–Ω–∞ —Ä–æ–±–æ—Ç–∞ ‚Ññ4</h1>
        <p class="subtitle">
            –ê–¥–∞–ø—Ç–∏–≤–Ω—ñ LSB –º–µ—Ç–æ–¥–∏: Edge-based embedding, PVD –º–µ—Ç–æ–¥, –ø–æ—Ä—ñ–≤–Ω—è–ª—å–Ω–∏–π –∞–Ω–∞–ª—ñ–∑
        </p>
        <div class="tool-badges">
            <span class="tool-badge">Python</span>
            <span class="tool-badge">OpenCV</span>
            <span class="tool-badge">NumPy</span>
            <span class="tool-badge">PIL/Pillow</span>
            <span class="tool-badge">Matplotlib</span>
            <span class="tool-badge">SciPy</span>
        </div>
    </div>
</header>

<!-- Main Content -->
<main class="container">

    <!-- –¶—ñ–ª—ñ —Ä–æ–±–æ—Ç–∏ -->
    <section class="task-box">
        <h2>üéØ –¶—ñ–ª—ñ –ª–∞–±–æ—Ä–∞—Ç–æ—Ä–Ω–æ—ó —Ä–æ–±–æ—Ç–∏</h2>
        <ul>
            <li>–í–∏–≤—á–∏—Ç–∏ –æ–±–º–µ–∂–µ–Ω–Ω—è –∫–ª–∞—Å–∏—á–Ω–æ–≥–æ LSB –º–µ—Ç–æ–¥—É —Ç–∞ –ø–æ—Ç—Ä–µ–±—É –≤ –∞–¥–∞–ø—Ç–∏–≤–Ω–∏—Ö –ø—ñ–¥—Ö–æ–¥–∞—Ö</li>
            <li>–û—Å–≤–æ—ó—Ç–∏ –º–µ—Ç–æ–¥–∏ –¥–µ—Ç–µ–∫—Ü—ñ—ó –∫—Ä–∞—ó–≤ (Sobel, Canny) –¥–ª—è –≤–∏–∑–Ω–∞—á–µ–Ω–Ω—è –æ–±–ª–∞—Å—Ç–µ–π –≤–±—É–¥–æ–≤—É–≤–∞–Ω–Ω—è</li>
            <li>–†–µ–∞–ª—ñ–∑—É–≤–∞—Ç–∏ Edge-based LSB –∑ –∞–¥–∞–ø—Ç–∏–≤–Ω–æ—é —î–º–Ω—ñ—Å—Ç—é</li>
            <li>–Ü–º–ø–ª–µ–º–µ–Ω—Ç—É–≤–∞—Ç–∏ PVD (Pixel Value Differencing) –º–µ—Ç–æ–¥</li>
            <li>–ü—Ä–æ–≤–µ—Å—Ç–∏ –ø–æ—Ä—ñ–≤–Ω—è–ª—å–Ω–∏–π –∞–Ω–∞–ª—ñ–∑ —Ä—ñ–∑–Ω–∏—Ö –º–µ—Ç–æ–¥—ñ–≤ —Å—Ç–µ–≥–∞–Ω–æ–≥—Ä–∞—Ñ—ñ—ó</li>
        </ul>
    </section>

    <!-- –¢–µ–æ—Ä–µ—Ç–∏—á–Ω–∞ —á–∞—Å—Ç–∏–Ω–∞ -->
    <section>
        <h2>üìö –¢–µ–æ—Ä–µ—Ç–∏—á–Ω–∞ —á–∞—Å—Ç–∏–Ω–∞</h2>

        <div class="tabs-container">
            <div class="tabs-nav">
                <button class="tab-button active" onclick="switchTab(event, 'adaptive-theory')">
                    üéØ –ê–¥–∞–ø—Ç–∏–≤–Ω—ñ –º–µ—Ç–æ–¥–∏
                </button>
                <button class="tab-button" onclick="switchTab(event, 'edge-detection')">
                    üîç –î–µ—Ç–µ–∫—Ü—ñ—è –∫—Ä–∞—ó–≤
                </button>
                <button class="tab-button" onclick="switchTab(event, 'edge-based')">
                    üìä Edge-based LSB
                </button>
                <button class="tab-button" onclick="switchTab(event, 'pvd-theory')">
                    üìà PVD –º–µ—Ç–æ–¥
                </button>
            </div>

            <!-- –ê–¥–∞–ø—Ç–∏–≤–Ω—ñ –º–µ—Ç–æ–¥–∏ -->
            <div class="tab-content active" id="adaptive-theory">
                <h3>–ü—Ä–æ–±–ª–µ–º–∏ –∫–ª–∞—Å–∏—á–Ω–æ–≥–æ LSB —Ç–∞ –∞–¥–∞–ø—Ç–∏–≤–Ω—ñ —Ä—ñ—à–µ–Ω–Ω—è</h3>

                <div class="detection-method">
                    <h4>‚ö†Ô∏è –û–±–º–µ–∂–µ–Ω–Ω—è –∫–ª–∞—Å–∏—á–Ω–æ–≥–æ LSB</h4>
                    <p>
                        –ö–ª–∞—Å–∏—á–Ω–∏–π LSB –º–µ—Ç–æ–¥ –º–∞—î –∫—Ä–∏—Ç–∏—á–Ω—ñ –Ω–µ–¥–æ–ª—ñ–∫–∏, —è–∫—ñ —Ä–æ–±–ª—è—Ç—å –π–æ–≥–æ –≤—Ä–∞–∑–ª–∏–≤–∏–º –¥–æ —Å—Ç–µ–≥–∞–Ω–æ–∞–Ω–∞–ª—ñ–∑—É:
                    </p>
                    <ul>
                        <li><strong>–†—ñ–≤–Ω–æ–º—ñ—Ä–Ω–∞ –º–æ–¥–∏—Ñ—ñ–∫–∞—Ü—ñ—è:</strong> –∑–º—ñ–Ω—é—î –≤—Å—ñ –ø—ñ–∫—Å–µ–ª—ñ –æ–¥–Ω–∞–∫–æ–≤–æ –Ω–µ–∑–∞–ª–µ–∂–Ω–æ –≤—ñ–¥ –∫–æ–Ω—Ç–µ–∫—Å—Ç—É</li>
                        <li><strong>–°—Ç–∞—Ç–∏—Å—Ç–∏—á–Ω—ñ –∞–Ω–æ–º–∞–ª—ñ—ó:</strong> —Å—Ç–≤–æ—Ä—é—î —Ö–∞—Ä–∞–∫—Ç–µ—Ä–Ω—ñ –ø–∞—Ç–µ—Ä–Ω–∏ –≤ –≥—ñ—Å—Ç–æ–≥—Ä–∞–º–∞—Ö</li>
                        <li><strong>–í—ñ–∑—É–∞–ª—å–Ω—ñ –∞—Ä—Ç–µ—Ñ–∞–∫—Ç–∏:</strong> –ø–æ–º—ñ—Ç–Ω—ñ –∑–º—ñ–Ω–∏ –≤ –≥–ª–∞–¥–∫–∏—Ö –æ–±–ª–∞—Å—Ç—è—Ö</li>
                        <li><strong>–õ–µ–≥–∫–µ –≤–∏—è–≤–ª–µ–Ω–Ω—è:</strong> Chi-square —Ç–∞ RS –∞–Ω–∞–ª—ñ–∑ –ª–µ–≥–∫–æ –¥–µ—Ç–µ–∫—Ç—É—é—Ç—å</li>
                    </ul>

                    <div class="formula-box">
                        <strong>–ö–ª—é—á–æ–≤–∞ —ñ–¥–µ—è –∞–¥–∞–ø—Ç–∏–≤–Ω–∏—Ö –º–µ—Ç–æ–¥—ñ–≤:</strong><br>
                        –Ñ–º–Ω—ñ—Å—Ç—å(pixel) = f(–°–∫–ª–∞–¥–Ω—ñ—Å—Ç—å_—Ä–µ–≥—ñ–æ–Ω—É)<br><br>
                        –ì–ª–∞–¥–∫—ñ –æ–±–ª–∞—Å—Ç—ñ ‚Üí –º—ñ–Ω—ñ–º–∞–ª—å–Ω–µ –≤–±—É–¥–æ–≤—É–≤–∞–Ω–Ω—è<br>
                        –¢–µ–∫—Å—Ç—É—Ä–Ω—ñ –æ–±–ª–∞—Å—Ç—ñ ‚Üí –º–∞–∫—Å–∏–º–∞–ª—å–Ω–µ –≤–±—É–¥–æ–≤—É–≤–∞–Ω–Ω—è
                    </div>
                </div>

                <div class="detection-method">
                    <h4>üéØ –ü—Ä–∏–Ω—Ü–∏–ø–∏ –∞–¥–∞–ø—Ç–∏–≤–Ω–æ—ó —Å—Ç–µ–≥–∞–Ω–æ–≥—Ä–∞—Ñ—ñ—ó</h4>
                    <p>
                        –ê–¥–∞–ø—Ç–∏–≤–Ω—ñ –º–µ—Ç–æ–¥–∏ –≤—Ä–∞—Ö–æ–≤—É—é—Ç—å —Ö–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫–∏ –∑–æ–±—Ä–∞–∂–µ–Ω–Ω—è –¥–ª—è –æ–ø—Ç–∏–º–∞–ª—å–Ω–æ–≥–æ –≤–±—É–¥–æ–≤—É–≤–∞–Ω–Ω—è:
                    </p>

                    <table style="width: 100%; margin: 1rem 0;">
                        <thead>
                        <tr>
                            <th>–ú–µ—Ç–æ–¥</th>
                            <th>–ö—Ä–∏—Ç–µ—Ä—ñ–π –∞–¥–∞–ø—Ç–∞—Ü—ñ—ó</th>
                            <th>–ü–µ—Ä–µ–≤–∞–≥–∏</th>
                            <th>–ù–µ–¥–æ–ª—ñ–∫–∏</th>
                        </tr>
                        </thead>
                        <tbody>
                        <tr>
                            <td>Edge-based</td>
                            <td>–ù–∞—è–≤–Ω—ñ—Å—Ç—å –∫—Ä–∞—ó–≤</td>
                            <td>–°—Ç—ñ–π–∫—ñ—Å—Ç—å –¥–æ –≤—ñ–∑—É–∞–ª—å–Ω–æ–≥–æ –≤–∏—è–≤–ª–µ–Ω–Ω—è</td>
                            <td>–ú–µ–Ω—à–∞ —î–º–Ω—ñ—Å—Ç—å</td>
                        </tr>
                        <tr>
                            <td>PVD</td>
                            <td>–†—ñ–∑–Ω–∏—Ü—è –ø—ñ–∫—Å–µ–ª—ñ–≤</td>
                            <td>–•–æ—Ä–æ—à–∏–π –±–∞–ª–∞–Ω—Å</td>
                            <td>–°–∫–ª–∞–¥–Ω—ñ—Å—Ç—å —Ä–µ–∞–ª—ñ–∑–∞—Ü—ñ—ó</td>
                        </tr>
                        <tr>
                            <td>BPCS</td>
                            <td>–°–∫–ª–∞–¥–Ω—ñ—Å—Ç—å –±–ª–æ–∫—ñ–≤</td>
                            <td>–í–µ–ª–∏–∫–∞ —î–º–Ω—ñ—Å—Ç—å</td>
                            <td>–û–±—á–∏—Å–ª—é–≤–∞–ª—å–Ω–∞ —Å–∫–ª–∞–¥–Ω—ñ—Å—Ç—å</td>
                        </tr>
                        </tbody>
                    </table>
                </div>
            </div>

            <!-- –î–µ—Ç–µ–∫—Ü—ñ—è –∫—Ä–∞—ó–≤ -->
            <div class="tab-content" id="edge-detection">
                <h3>–ú–µ—Ç–æ–¥–∏ –¥–µ—Ç–µ–∫—Ü—ñ—ó –∫—Ä–∞—ó–≤</h3>

                <div class="detection-method">
                    <h4>üîç –û–ø–µ—Ä–∞—Ç–æ—Ä Sobel</h4>
                    <p>
                        –û–±—á–∏—Å–ª—é—î –≥—Ä–∞–¥—ñ—î–Ω—Ç —è—Å–∫—Ä–∞–≤–æ—Å—Ç—ñ –¥–ª—è –≤–∏—è–≤–ª–µ–Ω–Ω—è –∫—Ä–∞—ó–≤:
                    </p>

                    <div class="formula-box">
                        <strong>–Ø–¥—Ä–∞ Sobel:</strong><br><br>
                        Gx = [[-1, 0, 1],<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[-2, 0, 2],<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[-1, 0, 1]]<br><br>

                        Gy = [[-1, -2, -1],<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ 0,  0,  0],<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ 1,  2,  1]]<br><br>

                        G = ‚àö(Gx¬≤ + Gy¬≤)<br>
                        Œ∏ = arctan(Gy/Gx)
                    </div>

                    <ul>
                        <li><strong>–ü–µ—Ä–µ–≤–∞–≥–∏:</strong> –ø—Ä–æ—Å—Ç–∏–π, —à–≤–∏–¥–∫–∏–π, –µ—Ñ–µ–∫—Ç–∏–≤–Ω–∏–π –¥–ª—è —á—ñ—Ç–∫–∏—Ö –∫—Ä–∞—ó–≤</li>
                        <li><strong>–ù–µ–¥–æ–ª—ñ–∫–∏:</strong> —á—É—Ç–ª–∏–≤–∏–π –¥–æ —à—É–º—É, —Ñ—ñ–∫—Å–æ–≤–∞–Ω–∏–π —Ä–æ–∑–º—ñ—Ä —è–¥—Ä–∞</li>
                    </ul>
                </div>

                <div class="detection-method">
                    <h4>üéØ –î–µ—Ç–µ–∫—Ç–æ—Ä Canny</h4>
                    <p>
                        –ë–∞–≥–∞—Ç–æ–µ—Ç–∞–ø–Ω–∏–π –∞–ª–≥–æ—Ä–∏—Ç–º –¥–ª—è –æ–ø—Ç–∏–º–∞–ª—å–Ω–æ—ó –¥–µ—Ç–µ–∫—Ü—ñ—ó –∫—Ä–∞—ó–≤:
                    </p>

                    <div class="formula-box">
                        <strong>–ï—Ç–∞–ø–∏ –∞–ª–≥–æ—Ä–∏—Ç–º—É Canny:</strong><br>
                        1. –ì–∞—É—Å—ñ–≤—Å—å–∫–µ —Ä–æ–∑–º–∏—Ç—Ç—è (–∑–º–µ–Ω—à–µ–Ω–Ω—è —à—É–º—É)<br>
                        2. –û–±—á–∏—Å–ª–µ–Ω–Ω—è –≥—Ä–∞–¥—ñ—î–Ω—Ç—ñ–≤ (Sobel)<br>
                        3. Non-maximum suppression<br>
                        4. –ü–æ–¥–≤—ñ–π–Ω–∞ –ø–æ—Ä–æ–≥–æ–≤–∞ —Ñ—ñ–ª—å—Ç—Ä–∞—Ü—ñ—è<br>
                        5. Edge tracking by hysteresis
                    </div>

                    <ul>
                        <li><strong>–ü–µ—Ä–µ–≤–∞–≥–∏:</strong> –Ω–∏–∑—å–∫–∏–π —Ä—ñ–≤–µ–Ω—å –ø–æ–º–∏–ª–æ–∫, —Ç–æ—á–Ω–∞ –ª–æ–∫–∞–ª—ñ–∑–∞—Ü—ñ—è</li>
                        <li><strong>–ù–µ–¥–æ–ª—ñ–∫–∏:</strong> –æ–±—á–∏—Å–ª—é–≤–∞–ª—å–Ω–∞ —Å–∫–ª–∞–¥–Ω—ñ—Å—Ç—å, –±–∞–≥–∞—Ç–æ –ø–∞—Ä–∞–º–µ—Ç—Ä—ñ–≤</li>
                    </ul>
                </div>
            </div>

            <!-- Edge-based LSB -->
            <div class="tab-content" id="edge-based">
                <h3>Edge-based LSB Embedding</h3>

                <div class="detection-method">
                    <h4>üìä –ö–ª–∞—Å–∏—Ñ—ñ–∫–∞—Ü—ñ—è —Ä–µ–≥—ñ–æ–Ω—ñ–≤</h4>
                    <p>
                        –ê–ª–≥–æ—Ä–∏—Ç–º —Ä–æ–∑–¥—ñ–ª—è—î –∑–æ–±—Ä–∞–∂–µ–Ω–Ω—è –Ω–∞ —Ä–µ–≥—ñ–æ–Ω–∏ –∑–∞ —Å–∫–ª–∞–¥–Ω—ñ—Å—Ç—é:
                    </p>

                    <div class="formula-box">
                        <strong>–ö–ª–∞—Å–∏—Ñ—ñ–∫–∞—Ü—ñ—è –ø—ñ–∫—Å–µ–ª—ñ–≤:</strong><br><br>
                        EdgeStrength(p) = |‚àáI(p)|<br><br>

                        –ö–ª–∞—Å(p) = {<br>
                        &nbsp;&nbsp;0 (smooth): EdgeStrength < T‚ÇÅ<br>
                        &nbsp;&nbsp;1 (edge): T‚ÇÅ ‚â§ EdgeStrength < T‚ÇÇ<br>
                        &nbsp;&nbsp;2 (complex): EdgeStrength ‚â• T‚ÇÇ<br>
                        }<br><br>

                        –Ñ–º–Ω—ñ—Å—Ç—å(p) = {<br>
                        &nbsp;&nbsp;0 –±—ñ—Ç: –¥–ª—è –∫–ª–∞—Å—É 0<br>
                        &nbsp;&nbsp;1 –±—ñ—Ç: –¥–ª—è –∫–ª–∞—Å—É 1<br>
                        &nbsp;&nbsp;2 –±—ñ—Ç–∏: –¥–ª—è –∫–ª–∞—Å—É 2<br>
                        }
                    </div>
                </div>

                <div class="detection-method">
                    <h4>üéØ –ê–¥–∞–ø—Ç–∏–≤–Ω–µ –≤–±—É–¥–æ–≤—É–≤–∞–Ω–Ω—è</h4>
                    <p>
                        –ü—Ä–æ—Ü–µ—Å –≤–±—É–¥–æ–≤—É–≤–∞–Ω–Ω—è –≤—Ä–∞—Ö–æ–≤—É—î –∫–ª–∞—Å–∏—Ñ—ñ–∫–∞—Ü—ñ—é —Ä–µ–≥—ñ–æ–Ω—ñ–≤:
                    </p>
                    <ul>
                        <li><strong>–ì–ª–∞–¥–∫—ñ –æ–±–ª–∞—Å—Ç—ñ:</strong> –±–µ–∑ –º–æ–¥–∏—Ñ—ñ–∫–∞—Ü—ñ—ó (–∑–±–µ—Ä–µ–∂–µ–Ω–Ω—è —è–∫–æ—Å—Ç—ñ)</li>
                        <li><strong>–ö—Ä–∞—ó:</strong> 1 –±—ñ—Ç –Ω–∞ –ø—ñ–∫—Å–µ–ª—å (–ø–æ–º—ñ—Ä–Ω–µ –≤–±—É–¥–æ–≤—É–≤–∞–Ω–Ω—è)</li>
                        <li><strong>–¢–µ–∫—Å—Ç—É—Ä–Ω—ñ –æ–±–ª–∞—Å—Ç—ñ:</strong> 2 –±—ñ—Ç–∏ –Ω–∞ –ø—ñ–∫—Å–µ–ª—å (–º–∞–∫—Å–∏–º–∞–ª—å–Ω–∞ —î–º–Ω—ñ—Å—Ç—å)</li>
                    </ul>
                </div>
            </div>

            <!-- PVD –º–µ—Ç–æ–¥ -->
            <div class="tab-content" id="pvd-theory">
                <h3>PVD (Pixel Value Differencing)</h3>

                <div class="detection-method">
                    <h4>üìà –ü—Ä–∏–Ω—Ü–∏–ø –º–µ—Ç–æ–¥—É PVD</h4>
                    <p>
                        PVD –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î —Ä—ñ–∑–Ω–∏—Ü—é –º—ñ–∂ —Å—É—Å—ñ–¥–Ω—ñ–º–∏ –ø—ñ–∫—Å–µ–ª—è–º–∏ –¥–ª—è –≤–∏–∑–Ω–∞—á–µ–Ω–Ω—è —î–º–Ω–æ—Å—Ç—ñ:
                    </p>

                    <div class="formula-box">
                        <strong>–ê–ª–≥–æ—Ä–∏—Ç–º PVD:</strong><br><br>
                        1. d = |p‚ÇÇ - p‚ÇÅ| (—Ä—ñ–∑–Ω–∏—Ü—è –ø—ñ–∫—Å–µ–ª—ñ–≤)<br>
                        2. –í–∏–∑–Ω–∞—á–∏—Ç–∏ –¥—ñ–∞–ø–∞–∑–æ–Ω R·µ¢ –¥–ª—è d<br>
                        3. –Ñ–º–Ω—ñ—Å—Ç—å = log‚ÇÇ(w·µ¢), –¥–µ w·µ¢ - —à–∏—Ä–∏–Ω–∞ –¥—ñ–∞–ø–∞–∑–æ–Ω—É<br>
                        4. d' = l·µ¢ + b (–Ω–æ–≤–∞ —Ä—ñ–∑–Ω–∏—Ü—è)<br>
                        5. m = d' - d (–º–æ–¥–∏—Ñ—ñ–∫–∞—Ü—ñ—è)<br>
                        6. p‚ÇÅ' = p‚ÇÅ - ‚åàm/2‚åâ, p‚ÇÇ' = p‚ÇÇ + ‚åäm/2‚åã
                    </div>
                </div>

                <div class="detection-method">
                    <h4>üìä –¢–∞–±–ª–∏—Ü—è –¥—ñ–∞–ø–∞–∑–æ–Ω—ñ–≤ Wu-Tsai</h4>

                    <table style="width: 100%; margin: 1rem 0;">
                        <thead>
                        <tr>
                            <th>–î—ñ–∞–ø–∞–∑–æ–Ω</th>
                            <th>–ù–∏–∂–Ω—è –º–µ–∂–∞ (l·µ¢)</th>
                            <th>–í–µ—Ä—Ö–Ω—è –º–µ–∂–∞ (u·µ¢)</th>
                            <th>–®–∏—Ä–∏–Ω–∞ (w·µ¢)</th>
                            <th>–Ñ–º–Ω—ñ—Å—Ç—å (–±—ñ—Ç)</th>
                        </tr>
                        </thead>
                        <tbody>
                        <tr><td>R‚ÇÅ</td><td>0</td><td>7</td><td>8</td><td>3</td></tr>
                        <tr><td>R‚ÇÇ</td><td>8</td><td>15</td><td>8</td><td>3</td></tr>
                        <tr><td>R‚ÇÉ</td><td>16</td><td>31</td><td>16</td><td>4</td></tr>
                        <tr><td>R‚ÇÑ</td><td>32</td><td>63</td><td>32</td><td>5</td></tr>
                        <tr><td>R‚ÇÖ</td><td>64</td><td>127</td><td>64</td><td>6</td></tr>
                        <tr><td>R‚ÇÜ</td><td>128</td><td>255</td><td>128</td><td>7</td></tr>
                        </tbody>
                    </table>

                    <p><strong>–ü–µ—Ä–µ–≤–∞–≥–∏ PVD:</strong></p>
                    <ul>
                        <li>–ê–¥–∞–ø—Ç–∏–≤–Ω–∞ —î–º–Ω—ñ—Å—Ç—å –∑–∞–ª–µ–∂–Ω–æ –≤—ñ–¥ –ª–æ–∫–∞–ª—å–Ω–æ—ó –≤–∞—Ä—ñ–∞—Ü—ñ—ó</li>
                        <li>–ú–µ–Ω—à—ñ –∑–º—ñ–Ω–∏ –≤ –≥–ª–∞–¥–∫–∏—Ö –æ–±–ª–∞—Å—Ç—è—Ö</li>
                        <li>–°—Ç—ñ–π–∫—ñ—Å—Ç—å –¥–æ –≥—ñ—Å—Ç–æ–≥—Ä–∞–º–Ω–æ–≥–æ –∞–Ω–∞–ª—ñ–∑—É</li>
                    </ul>
                </div>
            </div>
        </div>
    </section>

    <!-- –ü—Ä–∞–∫—Ç–∏—á–Ω–∞ —á–∞—Å—Ç–∏–Ω–∞ -->
    <section>
        <h2>üíª –ü—Ä–∞–∫—Ç–∏—á–Ω–∞ —á–∞—Å—Ç–∏–Ω–∞</h2>

        <!-- –ó–∞–≤–¥–∞–Ω–Ω—è 1 -->
        <div class="task-box">
            <h3><span class="step-number">1</span>–ù–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è —Å–µ—Ä–µ–¥–æ–≤–∏—â–∞</h3>

            <h4>–í—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–Ω—è –Ω–µ–æ–±—Ö—ñ–¥–Ω–∏—Ö –±—ñ–±–ª—ñ–æ—Ç–µ–∫:</h4>
            <pre class="python"><code>pip install numpy opencv-python pillow matplotlib scipy scikit-image</code></pre>

            <h4>–Ü–º–ø–æ—Ä—Ç –±—ñ–±–ª—ñ–æ—Ç–µ–∫ —Ç–∞ –±–∞–∑–æ–≤—ñ —Ñ—É–Ω–∫—Ü—ñ—ó:</h4>
            <pre class="python"><code>import numpy as np
import cv2
from PIL import Image
import matplotlib.pyplot as plt
from scipy import signal, stats
from skimage.metrics import structural_similarity as ssim
import time
import warnings
warnings.filterwarnings('ignore')

# –î–æ–ø–æ–º—ñ–∂–Ω—ñ —Ñ—É–Ω–∫—Ü—ñ—ó
def text_to_binary(text):
    """–ö–æ–Ω–≤–µ—Ä—Ç—É—î —Ç–µ–∫—Å—Ç —É –±—ñ–Ω–∞—Ä–Ω–∏–π —Ä—è–¥–æ–∫"""
    return ''.join(format(ord(char), '08b') for char in text)

def binary_to_text(binary):
    """–ö–æ–Ω–≤–µ—Ä—Ç—É—î –±—ñ–Ω–∞—Ä–Ω–∏–π —Ä—è–¥–æ–∫ —É —Ç–µ–∫—Å—Ç"""
    text = ''
    for i in range(0, len(binary), 8):
        byte = binary[i:i+8]
        if len(byte) == 8:
            text += chr(int(byte, 2))
    return text

def calculate_psnr(original, stego):
    """–û–±—á–∏—Å–ª—é—î PSNR –º—ñ–∂ –¥–≤–æ–º–∞ –∑–æ–±—Ä–∞–∂–µ–Ω–Ω—è–º–∏"""
    mse = np.mean((original.astype(float) - stego.astype(float)) ** 2)
    if mse == 0:
        return float('inf')
    max_pixel = 255.0
    psnr = 20 * np.log10(max_pixel / np.sqrt(mse))
    return psnr

def calculate_ssim(original, stego):
    """–û–±—á–∏—Å–ª—é—î SSIM –º—ñ–∂ –¥–≤–æ–º–∞ –∑–æ–±—Ä–∞–∂–µ–Ω–Ω—è–º–∏"""
    if len(original.shape) == 3:
        original_gray = cv2.cvtColor(original, cv2.COLOR_BGR2GRAY)
    else:
        original_gray = original

    if len(stego.shape) == 3:
        stego_gray = cv2.cvtColor(stego, cv2.COLOR_BGR2GRAY)
    else:
        stego_gray = stego

    return ssim(original_gray, stego_gray)

print("–ë—ñ–±–ª—ñ–æ—Ç–µ–∫–∏ —É—Å–ø—ñ—à–Ω–æ —ñ–º–ø–æ—Ä—Ç–æ–≤–∞–Ω–æ!")
print("OpenCV –≤–µ—Ä—Å—ñ—è:", cv2.__version__)</code></pre>

            <div class="result-box">
                <h4>‚úÖ –û—á—ñ–∫—É–≤–∞–Ω—ñ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∏:</h4>
                <ul>
                    <li>–£—Å–ø—ñ—à–Ω–∏–π —ñ–º–ø–æ—Ä—Ç –≤—Å—ñ—Ö –±—ñ–±–ª—ñ–æ—Ç–µ–∫</li>
                    <li>–í–∏–≤—ñ–¥ –≤–µ—Ä—Å—ñ—ó OpenCV (–ø–æ–≤–∏–Ω–Ω–∞ –±—É—Ç–∏ 4.x.x)</li>
                    <li>–ì–æ—Ç–æ–≤–Ω—ñ—Å—Ç—å –¥–æ–ø–æ–º—ñ–∂–Ω–∏—Ö —Ñ—É–Ω–∫—Ü—ñ–π –¥–æ –≤–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è</li>
                </ul>
            </div>
        </div>

        <!-- –ó–∞–≤–¥–∞–Ω–Ω—è 2 -->
        <div class="task-box">
            <h3><span class="step-number">2</span>–î–µ—Ç–µ–∫—Ü—ñ—è –∫—Ä–∞—ó–≤</h3>

            <h4>–†–µ–∞–ª—ñ–∑–∞—Ü—ñ—è –¥–µ—Ç–µ–∫—Ç–æ—Ä–∞ Sobel:</h4>
            <pre class="python"><code>def sobel_edge_detection(image, threshold=50):
    """
    –î–µ—Ç–µ–∫—Ç–æ—Ä –∫—Ä–∞—ó–≤ Sobel

    Parameters:
    -----------
    image : numpy array - –≤—Ö—ñ–¥–Ω–µ –∑–æ–±—Ä–∞–∂–µ–Ω–Ω—è
    threshold : int - –ø–æ—Ä—ñ–≥ –¥–ª—è –≤–∏–∑–Ω–∞—á–µ–Ω–Ω—è –∫—Ä–∞—ó–≤

    Returns:
    --------
    edge_map : numpy array - –±—ñ–Ω–∞—Ä–Ω–∞ –∫–∞—Ä—Ç–∞ –∫—Ä–∞—ó–≤
    edge_strength : numpy array - —Å–∏–ª–∞ –∫—Ä–∞—ó–≤
    """
    # –ö–æ–Ω–≤–µ—Ä—Ç—É—î–º–æ –≤ grayscale —è–∫—â–æ –ø–æ—Ç—Ä—ñ–±–Ω–æ
    if len(image.shape) == 3:
        gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
    else:
        gray = image.copy()

    # –û–±—á–∏—Å–ª—é—î–º–æ –≥—Ä–∞–¥—ñ—î–Ω—Ç–∏ –ø–æ X —Ç–∞ Y
    grad_x = cv2.Sobel(gray, cv2.CV_64F, 1, 0, ksize=3)
    grad_y = cv2.Sobel(gray, cv2.CV_64F, 0, 1, ksize=3)

    # –û–±—á–∏—Å–ª—é—î–º–æ –º–∞–≥–Ω—ñ—Ç—É–¥—É –≥—Ä–∞–¥—ñ—î–Ω—Ç–∞
    edge_strength = np.sqrt(grad_x**2 + grad_y**2)

    # –ù–æ—Ä–º–∞–ª—ñ–∑—É—î–º–æ –¥–æ –¥—ñ–∞–ø–∞–∑–æ–Ω—É [0, 255]
    edge_strength = np.clip(edge_strength, 0, 255).astype(np.uint8)

    # –°—Ç–≤–æ—Ä—é—î–º–æ –±—ñ–Ω–∞—Ä–Ω—É –º–∞—Å–∫—É –∫—Ä–∞—ó–≤
    edge_map = (edge_strength > threshold).astype(np.uint8) * 255

    return edge_map, edge_strength

def canny_edge_detection(image, low_threshold=50, high_threshold=150):
    """–î–µ—Ç–µ–∫—Ç–æ—Ä –∫—Ä–∞—ó–≤ Canny –∑ –ø–æ–¥–≤—ñ–π–Ω–æ—é –ø–æ—Ä–æ–≥–æ–≤–æ—é —Ñ—ñ–ª—å—Ç—Ä–∞—Ü—ñ—î—é"""
    if len(image.shape) == 3:
        gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
    else:
        gray = image.copy()

    # –ó–∞—Å—Ç–æ—Å–æ–≤—É—î–º–æ Gaussian blur –¥–ª—è –∑–º–µ–Ω—à–µ–Ω–Ω—è —à—É–º—É
    blurred = cv2.GaussianBlur(gray, (5, 5), 1.4)

    # –î–µ—Ç–µ–∫—Ü—ñ—è –∫—Ä–∞—ó–≤ –º–µ—Ç–æ–¥–æ–º Canny
    edges = cv2.Canny(blurred, low_threshold, high_threshold)

    return edges

# –¢–µ—Å—Ç—É–≤–∞–Ω–Ω—è –¥–µ—Ç–µ–∫—Ç–æ—Ä—ñ–≤
def test_edge_detectors():
    """–¢–µ—Å—Ç—É—î —Ä–æ–±–æ—Ç—É –¥–µ—Ç–µ–∫—Ç–æ—Ä—ñ–≤ –∫—Ä–∞—ó–≤"""
    # –°—Ç–≤–æ—Ä—é—î–º–æ —Ç–µ—Å—Ç–æ–≤–µ –∑–æ–±—Ä–∞–∂–µ–Ω–Ω—è
    test_image = np.random.randint(0, 256, (256, 256), dtype=np.uint8)

    # –î–æ–¥–∞—î–º–æ –≥–µ–æ–º–µ—Ç—Ä–∏—á–Ω—ñ —Ñ—ñ–≥—É—Ä–∏
    cv2.rectangle(test_image, (50, 50), (200, 200), 255, 2)
    cv2.circle(test_image, (128, 128), 50, 0, -1)
    cv2.line(test_image, (0, 128), (255, 128), 128, 1)

    # –ó–∞—Å—Ç–æ—Å–æ–≤—É—î–º–æ –¥–µ—Ç–µ–∫—Ç–æ—Ä–∏
    edge_map_sobel, edge_strength_sobel = sobel_edge_detection(test_image)
    edge_map_canny = canny_edge_detection(test_image)

    # –í—ñ–∑—É–∞–ª—ñ–∑–∞—Ü—ñ—è —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ñ–≤
    fig, axes = plt.subplots(2, 3, figsize=(15, 10))

    axes[0, 0].imshow(test_image, cmap='gray')
    axes[0, 0].set_title('–û—Ä–∏–≥—ñ–Ω–∞–ª—å–Ω–µ –∑–æ–±—Ä–∞–∂–µ–Ω–Ω—è')
    axes[0, 0].axis('off')

    axes[0, 1].imshow(edge_strength_sobel, cmap='gray')
    axes[0, 1].set_title('Sobel: –°–∏–ª–∞ –∫—Ä–∞—ó–≤')
    axes[0, 1].axis('off')

    axes[0, 2].imshow(edge_map_sobel, cmap='gray')
    axes[0, 2].set_title('Sobel: –ë—ñ–Ω–∞—Ä–Ω–∞ –∫–∞—Ä—Ç–∞')
    axes[0, 2].axis('off')

    axes[1, 0].imshow(test_image, cmap='gray')
    axes[1, 0].set_title('–û—Ä–∏–≥—ñ–Ω–∞–ª—å–Ω–µ –∑–æ–±—Ä–∞–∂–µ–Ω–Ω—è')
    axes[1, 0].axis('off')

    axes[1, 1].imshow(edge_map_canny, cmap='gray')
    axes[1, 1].set_title('Canny: –î–µ—Ç–µ–∫—Ü—ñ—è –∫—Ä–∞—ó–≤')
    axes[1, 1].axis('off')

    # –ü–æ—Ä—ñ–≤–Ω—è–Ω–Ω—è –º–µ—Ç–æ–¥—ñ–≤
    comparison = np.zeros_like(test_image)
    comparison[edge_map_sobel > 0] = 128
    comparison[edge_map_canny > 0] = 255
    axes[1, 2].imshow(comparison, cmap='gray')
    axes[1, 2].set_title('–ü–æ—Ä—ñ–≤–Ω—è–Ω–Ω—è: Sobel (—Å—ñ—Ä–∏–π) vs Canny (–±—ñ–ª–∏–π)')
    axes[1, 2].axis('off')

    plt.tight_layout()
    plt.show()

    print(f"–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –¥–µ—Ç–µ–∫—Ü—ñ—ó –∫—Ä–∞—ó–≤:")
    print(f"  Sobel: {np.sum(edge_map_sobel > 0)} –ø—ñ–∫—Å–µ–ª—ñ–≤")
    print(f"  Canny: {np.sum(edge_map_canny > 0)} –ø—ñ–∫—Å–µ–ª—ñ–≤")
    print(f"  –ü–µ—Ä–µ—Ç–∏–Ω: {np.sum((edge_map_sobel > 0) & (edge_map_canny > 0))} –ø—ñ–∫—Å–µ–ª—ñ–≤")

# –ó–∞–ø—É—Å–∫ —Ç–µ—Å—Ç—É
test_edge_detectors()</code></pre>

            <div class="result-box">
                <h4>‚úÖ –û—á—ñ–∫—É–≤–∞–Ω—ñ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∏:</h4>
                <ul>
                    <li>–í—ñ–∑—É–∞–ª—ñ–∑–∞—Ü—ñ—è –∫–∞—Ä—Ç –∫—Ä–∞—ó–≤ –¥–ª—è –æ–±–æ—Ö –º–µ—Ç–æ–¥—ñ–≤</li>
                    <li>Sobel –≤–∏—è–≤–ª—è—î ~3500 –ø—ñ–∫—Å–µ–ª—ñ–≤ –∫—Ä–∞—ó–≤</li>
                    <li>Canny –≤–∏—è–≤–ª—è—î ~2800 –ø—ñ–∫—Å–µ–ª—ñ–≤ –∫—Ä–∞—ó–≤</li>
                    <li>Canny –¥–∞—î –±—ñ–ª—å—à —Ç–æ—á–Ω—É –ª–æ–∫–∞–ª—ñ–∑–∞—Ü—ñ—é –∫—Ä–∞—ó–≤</li>
                </ul>
            </div>
        </div>

        <!-- –ó–∞–≤–¥–∞–Ω–Ω—è 3 -->
        <div class="task-box">
            <h3><span class="step-number">3</span>Edge-based LSB Implementation</h3>

            <h4>–ö–ª–∞—Å–∏—Ñ—ñ–∫–∞—Ü—ñ—è –ø—ñ–∫—Å–µ–ª—ñ–≤ –∑–∞ —Å–∫–ª–∞–¥–Ω—ñ—Å—Ç—é:</h4>
            <pre class="python"><code>def classify_pixels(image, edge_threshold=50):
    """
    –ö–ª–∞—Å–∏—Ñ—ñ–∫—É—î –ø—ñ–∫—Å–µ–ª—ñ –Ω–∞ –æ—Å–Ω–æ–≤—ñ —Å–∫–ª–∞–¥–Ω–æ—Å—Ç—ñ —Ä–µ–≥—ñ–æ–Ω—É

    Returns:
    --------
    pixel_classes : numpy array
        0 - –≥–ª–∞–¥–∫–∞ –æ–±–ª–∞—Å—Ç—å (–±–µ–∑ –≤–±—É–¥–æ–≤—É–≤–∞–Ω–Ω—è)
        1 - –æ–±–ª–∞—Å—Ç—å –∫—Ä–∞—ó–≤ (1 –±—ñ—Ç)
        2 - —Å–∫–ª–∞–¥–Ω–∞ –æ–±–ª–∞—Å—Ç—å (2 –±—ñ—Ç–∏)
    """
    # –î–µ—Ç–µ–∫—Ü—ñ—è –∫—Ä–∞—ó–≤
    _, edge_strength = sobel_edge_detection(image, edge_threshold)

    # –ö–ª–∞—Å–∏—Ñ—ñ–∫–∞—Ü—ñ—è –ø—ñ–∫—Å–µ–ª—ñ–≤
    pixel_classes = np.zeros_like(edge_strength)

    # –í–∏–∑–Ω–∞—á–∞—î–º–æ –ø–æ—Ä–æ–≥–∏ –¥–ª—è –∫–ª–∞—Å–∏—Ñ—ñ–∫–∞—Ü—ñ—ó
    smooth_threshold = edge_threshold * 0.5
    complex_threshold = edge_threshold * 1.5

    # –ö–ª–∞—Å–∏—Ñ—ñ–∫–∞—Ü—ñ—è
    pixel_classes[edge_strength < smooth_threshold] = 0  # –ì–ª–∞–¥–∫—ñ –æ–±–ª–∞—Å—Ç—ñ
    pixel_classes[(edge_strength >= smooth_threshold) &
                 (edge_strength < complex_threshold)] = 1  # –ö—Ä–∞—ó
    pixel_classes[edge_strength >= complex_threshold] = 2  # –°–∫–ª–∞–¥–Ω—ñ –æ–±–ª–∞—Å—Ç—ñ

    return pixel_classes, edge_strength

def edge_based_embed(image, message, edge_threshold=50):
    """
    –í–±—É–¥–æ–≤—É—î –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—é—á–∏ Edge-based LSB

    Parameters:
    -----------
    image : numpy array - –æ—Ä–∏–≥—ñ–Ω–∞–ª—å–Ω–µ –∑–æ–±—Ä–∞–∂–µ–Ω–Ω—è
    message : str - –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è –¥–ª—è –≤–±—É–¥–æ–≤—É–≤–∞–Ω–Ω—è
    edge_threshold : int - –ø–æ—Ä—ñ–≥ –¥–ª—è –¥–µ—Ç–µ–∫—Ü—ñ—ó –∫—Ä–∞—ó–≤

    Returns:
    --------
    stego : numpy array - —Å—Ç–µ–≥–æ-–∑–æ–±—Ä–∞–∂–µ–Ω–Ω—è
    pixel_classes : numpy array - –∫–∞—Ä—Ç–∞ –∫–ª–∞—Å–∏—Ñ—ñ–∫–∞—Ü—ñ—ó –ø—ñ–∫—Å–µ–ª—ñ–≤
    """
    # –ö–æ–ø—ñ—é—î–º–æ –∑–æ–±—Ä–∞–∂–µ–Ω–Ω—è
    stego = image.copy()

    # –ö–ª–∞—Å–∏—Ñ—ñ–∫—É—î–º–æ –ø—ñ–∫—Å–µ–ª—ñ
    pixel_classes, edge_strength = classify_pixels(image, edge_threshold)

    # –ö–æ–Ω–≤–µ—Ä—Ç—É—î–º–æ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è –≤ –±—ñ–Ω–∞—Ä–Ω–∏–π —Ñ–æ—Ä–º–∞—Ç
    binary_message = text_to_binary(message)

    # –î–æ–¥–∞—î–º–æ –¥–æ–≤–∂–∏–Ω—É –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è (32 –±—ñ—Ç–∏)
    length = len(binary_message)
    length_binary = format(length, '032b')
    binary_message = length_binary + binary_message

    # –û–±—á–∏—Å–ª—é—î–º–æ –¥–æ—Å—Ç—É–ø–Ω—É —î–º–Ω—ñ—Å—Ç—å
    capacity_smooth = np.sum(pixel_classes == 0) * 0
    capacity_edge = np.sum(pixel_classes == 1) * 1
    capacity_complex = np.sum(pixel_classes == 2) * 2
    total_capacity = capacity_edge + capacity_complex

    print(f"–ê–Ω–∞–ª—ñ–∑ —î–º–Ω–æ—Å—Ç—ñ:")
    print(f"  –ì–ª–∞–¥–∫—ñ –æ–±–ª–∞—Å—Ç—ñ: {np.sum(pixel_classes == 0)} –ø—ñ–∫—Å–µ–ª—ñ–≤ (0 –±—ñ—Ç)")
    print(f"  –ö—Ä–∞—ó: {np.sum(pixel_classes == 1)} –ø—ñ–∫—Å–µ–ª—ñ–≤ ({capacity_edge} –±—ñ—Ç)")
    print(f"  –°–∫–ª–∞–¥–Ω—ñ –æ–±–ª–∞—Å—Ç—ñ: {np.sum(pixel_classes == 2)} –ø—ñ–∫—Å–µ–ª—ñ–≤ ({capacity_complex} –±—ñ—Ç)")
    print(f"  –ó–∞–≥–∞–ª—å–Ω–∞ —î–º–Ω—ñ—Å—Ç—å: {total_capacity} –±—ñ—Ç")

    if len(binary_message) > total_capacity:
        raise ValueError(f"–ü–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è –∑–∞–Ω–∞–¥—Ç–æ –≤–µ–ª–∏–∫–µ! –ü–æ—Ç—Ä—ñ–±–Ω–æ {len(binary_message)} –±—ñ—Ç, –¥–æ—Å—Ç—É–ø–Ω–æ {total_capacity} –±—ñ—Ç")

    # –í–±—É–¥–æ–≤—É–≤–∞–Ω–Ω—è –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è
    message_idx = 0
    pixels_modified = 0
    height, width = image.shape[:2]

    for y in range(height):
        for x in range(width):
            if message_idx >= len(binary_message):
                break

            pixel_class = pixel_classes[y, x]

            if pixel_class == 0:
                # –ì–ª–∞–¥–∫–∞ –æ–±–ª–∞—Å—Ç—å - –ø—Ä–æ–ø—É—Å–∫–∞—î–º–æ
                continue

            elif pixel_class == 1:
                # –û–±–ª–∞—Å—Ç—å –∫—Ä–∞—ó–≤ - –≤–±—É–¥–æ–≤—É—î–º–æ 1 –±—ñ—Ç
                bit = int(binary_message[message_idx])

                if len(stego.shape) == 3:
                    # –î–ª—è –∫–æ–ª—å–æ—Ä–æ–≤–æ–≥–æ –∑–æ–±—Ä–∞–∂–µ–Ω–Ω—è - –º–æ–¥–∏—Ñ—ñ–∫—É—î–º–æ —Å–∏–Ω—ñ–π –∫–∞–Ω–∞–ª
                    stego[y, x, 0] = (stego[y, x, 0] & 0xFE) | bit
                else:
                    # –î–ª—è grayscale
                    stego[y, x] = (stego[y, x] & 0xFE) | bit

                message_idx += 1
                pixels_modified += 1

            elif pixel_class == 2:
                # –°–∫–ª–∞–¥–Ω–∞ –æ–±–ª–∞—Å—Ç—å - –≤–±—É–¥–æ–≤—É—î–º–æ 2 –±—ñ—Ç–∏
                if len(stego.shape) == 3:
                    # –ü–µ—Ä—à–∏–π –±—ñ—Ç –≤ —Å–∏–Ω—ñ–π –∫–∞–Ω–∞–ª
                    if message_idx < len(binary_message):
                        bit1 = int(binary_message[message_idx])
                        stego[y, x, 0] = (stego[y, x, 0] & 0xFE) | bit1
                        message_idx += 1

                    # –î—Ä—É–≥–∏–π –±—ñ—Ç –≤ –∑–µ–ª–µ–Ω–∏–π –∫–∞–Ω–∞–ª
                    if message_idx < len(binary_message):
                        bit2 = int(binary_message[message_idx])
                        stego[y, x, 1] = (stego[y, x, 1] & 0xFE) | bit2
                        message_idx += 1
                else:
                    # –î–ª—è grayscale - –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î–º–æ 2 LSB
                    if message_idx < len(binary_message):
                        bit = int(binary_message[message_idx])
                        stego[y, x] = (stego[y, x] & 0xFE) | bit
                        message_idx += 1

                        if message_idx < len(binary_message):
                            bit = int(binary_message[message_idx])
                            stego[y, x] = (stego[y, x] & 0xFD) | (bit << 1)
                            message_idx += 1

                pixels_modified += 1

    # –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –≤–±—É–¥–æ–≤—É–≤–∞–Ω–Ω—è
    print(f"\n–†–µ–∑—É–ª—å—Ç–∞—Ç–∏ –≤–±—É–¥–æ–≤—É–≤–∞–Ω–Ω—è:")
    print(f"  –í–±—É–¥–æ–≤–∞–Ω–æ {message_idx} –±—ñ—Ç")
    print(f"  –ú–æ–¥–∏—Ñ—ñ–∫–æ–≤–∞–Ω–æ {pixels_modified} –ø—ñ–∫—Å–µ–ª—ñ–≤")
    print(f"  PSNR: {calculate_psnr(image, stego):.2f} dB")
    print(f"  SSIM: {calculate_ssim(image, stego):.4f}")

    return stego, pixel_classes

def edge_based_extract(stego_image, original_image, edge_threshold=50):
    """
    –í–∏—Ç—è–≥—É—î –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è –∑ —Å—Ç–µ–≥–æ-–∑–æ–±—Ä–∞–∂–µ–Ω–Ω—è

    Parameters:
    -----------
    stego_image : numpy array - —Å—Ç–µ–≥–æ-–∑–æ–±—Ä–∞–∂–µ–Ω–Ω—è
    original_image : numpy array - –æ—Ä–∏–≥—ñ–Ω–∞–ª—å–Ω–µ –∑–æ–±—Ä–∞–∂–µ–Ω–Ω—è (–¥–ª—è –∫–ª–∞—Å–∏—Ñ—ñ–∫–∞—Ü—ñ—ó)
    edge_threshold : int - –ø–æ—Ä—ñ–≥ –¥–µ—Ç–µ–∫—Ü—ñ—ó –∫—Ä–∞—ó–≤

    Returns:
    --------
    message : str - –≤–∏—Ç—è–≥–Ω—É—Ç–µ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è
    """
    # –ö–ª–∞—Å–∏—Ñ—ñ–∫—É—î–º–æ –ø—ñ–∫—Å–µ–ª—ñ –Ω–∞ –æ—Å–Ω–æ–≤—ñ –æ—Ä–∏–≥—ñ–Ω–∞–ª—å–Ω–æ–≥–æ –∑–æ–±—Ä–∞–∂–µ–Ω–Ω—è
    pixel_classes, _ = classify_pixels(original_image, edge_threshold)

    # –í–∏—Ç—è–≥—É–≤–∞–Ω–Ω—è –±—ñ—Ç—ñ–≤
    binary_message = ''
    height, width = stego_image.shape[:2]

    for y in range(height):
        for x in range(width):
            pixel_class = pixel_classes[y, x]

            if pixel_class == 0:
                # –ì–ª–∞–¥–∫–∞ –æ–±–ª–∞—Å—Ç—å - –ø—Ä–æ–ø—É—Å–∫–∞—î–º–æ
                continue

            elif pixel_class == 1:
                # –í–∏—Ç—è–≥—É—î–º–æ 1 –±—ñ—Ç
                if len(stego_image.shape) == 3:
                    bit = stego_image[y, x, 0] & 1
                else:
                    bit = stego_image[y, x] & 1
                binary_message += str(bit)

            elif pixel_class == 2:
                # –í–∏—Ç—è–≥—É—î–º–æ 2 –±—ñ—Ç–∏
                if len(stego_image.shape) == 3:
                    bit1 = stego_image[y, x, 0] & 1
                    bit2 = stego_image[y, x, 1] & 1
                    binary_message += str(bit1) + str(bit2)
                else:
                    bit1 = stego_image[y, x] & 1
                    bit2 = (stego_image[y, x] >> 1) & 1
                    binary_message += str(bit1) + str(bit2)

    # –í–∏—Ç—è–≥—É—î–º–æ –¥–æ–≤–∂–∏–Ω—É –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è
    if len(binary_message) < 32:
        return ""

    length_binary = binary_message[:32]
    length = int(length_binary, 2)

    # –í–∏—Ç—è–≥—É—î–º–æ —Å–∞–º–µ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è
    if length > 0 and 32 + length <= len(binary_message):
        message_binary = binary_message[32:32+length]
        return binary_to_text(message_binary)

    return ""

# –¢–µ—Å—Ç—É–≤–∞–Ω–Ω—è Edge-based LSB
def test_edge_based_lsb():
    """–¢–µ—Å—Ç—É—î Edge-based LSB —Å—Ç–µ–≥–∞–Ω–æ–≥—Ä–∞—Ñ—ñ—é"""

    # –°—Ç–≤–æ—Ä—é—î–º–æ —Ç–µ—Å—Ç–æ–≤–µ –∑–æ–±—Ä–∞–∂–µ–Ω–Ω—è –∑ —Ä—ñ–∑–Ω–∏–º–∏ —Ç–µ–∫—Å—Ç—É—Ä–∞–º–∏
    test_image = np.zeros((300, 400, 3), dtype=np.uint8)

    # –ì–ª–∞–¥–∫–∞ –æ–±–ª–∞—Å—Ç—å (–ª—ñ–≤–∏–π –≤–µ—Ä—Ö)
    test_image[:150, :200] = [100, 100, 100]

    # –¢–µ–∫—Å—Ç—É—Ä–Ω–∞ –æ–±–ª–∞—Å—Ç—å (–ø—Ä–∞–≤–∏–π –≤–µ—Ä—Ö)
    noise = np.random.randint(50, 200, (150, 200, 3))
    test_image[:150, 200:] = noise

    # –î–æ–¥–∞—î–º–æ –∫—Ä–∞—ó
    cv2.rectangle(test_image, (50, 200), (150, 280), (255, 255, 255), 2)
    cv2.circle(test_image, (300, 240), 30, (200, 200, 200), 2)
    cv2.line(test_image, (200, 150), (400, 300), (255, 0, 0), 3)

    # –¢–µ—Å—Ç–æ–≤–µ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è
    message = "Edge-based LSB: –ê–¥–∞–ø—Ç–∏–≤–Ω–∞ —Å—Ç–µ–≥–∞–Ω–æ–≥—Ä–∞—Ñ—ñ—è –ø—Ä–∞—Ü—é—î!"

    print("="*60)
    print("–¢–ï–°–¢–£–í–ê–ù–ù–Ø EDGE-BASED LSB")
    print("="*60)

    # –í–±—É–¥–æ–≤—É–≤–∞–Ω–Ω—è
    print("\n1. –í–±—É–¥–æ–≤—É–≤–∞–Ω–Ω—è –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è...")
    print(f"   –ü–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è: '{message}'")
    print(f"   –î–æ–≤–∂–∏–Ω–∞: {len(message)} —Å–∏–º–≤–æ–ª—ñ–≤ ({len(text_to_binary(message))} –±—ñ—Ç)")

    stego, pixel_classes = edge_based_embed(test_image, message, edge_threshold=50)

    # –í–∏—Ç—è–≥—É–≤–∞–Ω–Ω—è
    print("\n2. –í–∏—Ç—è–≥—É–≤–∞–Ω–Ω—è –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è...")
    extracted = edge_based_extract(stego, test_image, edge_threshold=50)

    print(f"   –í–∏—Ç—è–≥–Ω—É—Ç–µ: '{extracted}'")
    print(f"   –£—Å–ø—ñ—à–Ω—ñ—Å—Ç—å: {'‚úÖ –ü–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è —Å–ø—ñ–≤–ø–∞–¥–∞—î!' if message == extracted else '‚ùå –ü–æ–º–∏–ª–∫–∞ –≤–∏—Ç—è–≥—É–≤–∞–Ω–Ω—è'}")

    # –í—ñ–∑—É–∞–ª—ñ–∑–∞—Ü—ñ—è
    fig, axes = plt.subplots(2, 3, figsize=(15, 10))

    axes[0, 0].imshow(cv2.cvtColor(test_image, cv2.COLOR_BGR2RGB))
    axes[0, 0].set_title('–û—Ä–∏–≥—ñ–Ω–∞–ª—å–Ω–µ –∑–æ–±—Ä–∞–∂–µ–Ω–Ω—è')
    axes[0, 0].axis('off')

    # –ö–∞—Ä—Ç–∞ –∫–ª–∞—Å–∏—Ñ—ñ–∫–∞—Ü—ñ—ó –∑ –∫–æ–ª—å–æ—Ä–æ–≤–∏–º –∫–æ–¥—É–≤–∞–Ω–Ω—è–º
    class_colors = np.zeros((*pixel_classes.shape, 3), dtype=np.uint8)
    class_colors[pixel_classes == 0] = [0, 0, 255]    # –°–∏–Ω—ñ–π - –≥–ª–∞–¥–∫—ñ
    class_colors[pixel_classes == 1] = [0, 255, 0]    # –ó–µ–ª–µ–Ω–∏–π - –∫—Ä–∞—ó
    class_colors[pixel_classes == 2] = [255, 0, 0]    # –ß–µ—Ä–≤–æ–Ω–∏–π - —Å–∫–ª–∞–¥–Ω—ñ

    axes[0, 1].imshow(class_colors)
    axes[0, 1].set_title('–ö–ª–∞—Å–∏—Ñ—ñ–∫–∞—Ü—ñ—è –ø—ñ–∫—Å–µ–ª—ñ–≤\n(–°–∏–Ω—ñ–π: 0 –±—ñ—Ç, –ó–µ–ª–µ–Ω–∏–π: 1 –±—ñ—Ç, –ß–µ—Ä–≤–æ–Ω–∏–π: 2 –±—ñ—Ç–∏)')
    axes[0, 1].axis('off')

    axes[0, 2].imshow(cv2.cvtColor(stego, cv2.COLOR_BGR2RGB))
    axes[0, 2].set_title(f'–°—Ç–µ–≥–æ-–∑–æ–±—Ä–∞–∂–µ–Ω–Ω—è\n(PSNR: {calculate_psnr(test_image, stego):.2f} dB)')
    axes[0, 2].axis('off')

    # –†—ñ–∑–Ω–∏—Ü—è –º—ñ–∂ –æ—Ä–∏–≥—ñ–Ω–∞–ª–æ–º —Ç–∞ —Å—Ç–µ–≥–æ
    diff = np.abs(test_image.astype(int) - stego.astype(int))
    axes[1, 0].imshow(diff * 50)  # –ü–æ—Å–∏–ª—é—î–º–æ –¥–ª—è –≤—ñ–∑—É–∞–ª—ñ–∑–∞—Ü—ñ—ó
    axes[1, 0].set_title('–†—ñ–∑–Ω–∏—Ü—è (√ó50)')
    axes[1, 0].axis('off')

    # –ì—ñ—Å—Ç–æ–≥—Ä–∞–º–∞ –∫–ª–∞—Å–∏—Ñ—ñ–∫–∞—Ü—ñ—ó
    axes[1, 1].bar(['–ì–ª–∞–¥–∫—ñ\n(0 –±—ñ—Ç)', '–ö—Ä–∞—ó\n(1 –±—ñ—Ç)', '–°–∫–ª–∞–¥–Ω—ñ\n(2 –±—ñ—Ç–∏)'],
                   [np.sum(pixel_classes == 0),
                    np.sum(pixel_classes == 1),
                    np.sum(pixel_classes == 2)],
                   color=['blue', 'green', 'red'])
    axes[1, 1].set_title('–†–æ–∑–ø–æ–¥—ñ–ª –ø—ñ–∫—Å–µ–ª—ñ–≤ –∑–∞ –∫–ª–∞—Å–∞–º–∏')
    axes[1, 1].set_ylabel('–ö—ñ–ª—å–∫—ñ—Å—Ç—å –ø—ñ–∫—Å–µ–ª—ñ–≤')

    # –ö–∞—Ä—Ç–∞ –º–æ–¥–∏—Ñ—ñ–∫–∞—Ü—ñ–π
    modified_map = np.zeros_like(pixel_classes)
    modified_map[(pixel_classes == 1) | (pixel_classes == 2)] = 255
    axes[1, 2].imshow(modified_map, cmap='gray')
    axes[1, 2].set_title('–ö–∞—Ä—Ç–∞ –º–æ–¥–∏—Ñ—ñ–∫–æ–≤–∞–Ω–∏—Ö –ø—ñ–∫—Å–µ–ª—ñ–≤')
    axes[1, 2].axis('off')

    plt.tight_layout()
    plt.show()

# –ó–∞–ø—É—Å–∫ —Ç–µ—Å—Ç—É
test_edge_based_lsb()</code></pre>
        </div>

        <!-- –ó–∞–≤–¥–∞–Ω–Ω—è 4 -->
        <div class="task-box">
            <h3><span class="step-number">4</span>PVD (Pixel Value Differencing) –º–µ—Ç–æ–¥</h3>

            <h4>–†–µ–∞–ª—ñ–∑–∞—Ü—ñ—è PVD —Å—Ç–µ–≥–∞–Ω–æ–≥—Ä–∞—Ñ—ñ—ó:</h4>
            <pre class="python"><code># –¢–∞–±–ª–∏—Ü—è –¥—ñ–∞–ø–∞–∑–æ–Ω—ñ–≤ Wu-Tsai
RANGE_TABLE_WU = [
    (0, 7, 3),      # Range 1: [0,7], —î–º–Ω—ñ—Å—Ç—å 3 –±—ñ—Ç–∏
    (8, 15, 3),     # Range 2: [8,15], —î–º–Ω—ñ—Å—Ç—å 3 –±—ñ—Ç–∏
    (16, 31, 4),    # Range 3: [16,31], —î–º–Ω—ñ—Å—Ç—å 4 –±—ñ—Ç–∏
    (32, 63, 5),    # Range 4: [32,63], —î–º–Ω—ñ—Å—Ç—å 5 –±—ñ—Ç–∏
    (64, 127, 6),   # Range 5: [64,127], —î–º–Ω—ñ—Å—Ç—å 6 –±—ñ—Ç–∏
    (128, 255, 7)   # Range 6: [128,255], —î–º–Ω—ñ—Å—Ç—å 7 –±—ñ—Ç–∏
]

def find_range(difference):
    """–ó–Ω–∞—Ö–æ–¥–∏—Ç—å –¥—ñ–∞–ø–∞–∑–æ–Ω –¥–ª—è –∑–∞–¥–∞–Ω–æ—ó —Ä—ñ–∑–Ω–∏—Ü—ñ"""
    abs_diff = abs(difference)
    for lower, upper, capacity in RANGE_TABLE_WU:
        if lower <= abs_diff <= upper:
            return lower, upper, capacity
    return 128, 255, 7  # –ó–∞ –∑–∞–º–æ–≤—á—É–≤–∞–Ω–Ω—è–º –æ—Å—Ç–∞–Ω–Ω—ñ–π –¥—ñ–∞–ø–∞–∑–æ–Ω

def embed_block_pvd(p1, p2, secret_bits):
    """
    –í–±—É–¥–æ–≤—É—î –±—ñ—Ç–∏ –≤ –æ–¥–∏–Ω –±–ª–æ–∫ –∑–∞ –º–µ—Ç–æ–¥–æ–º PVD

    Parameters:
    -----------
    p1, p2 : int - –∑–Ω–∞—á–µ–Ω–Ω—è –ø—ñ–∫—Å–µ–ª—ñ–≤
    secret_bits : str - –±—ñ–Ω–∞—Ä–Ω–∏–π —Ä—è–¥–æ–∫ –¥–ª—è –≤–±—É–¥–æ–≤—É–≤–∞–Ω–Ω—è

    Returns:
    --------
    new_p1, new_p2 : int - –º–æ–¥–∏—Ñ—ñ–∫–æ–≤–∞–Ω—ñ –∑–Ω–∞—á–µ–Ω–Ω—è –ø—ñ–∫—Å–µ–ª—ñ–≤
    embedded_bits : int - –∫—ñ–ª—å–∫—ñ—Å—Ç—å –≤–±—É–¥–æ–≤–∞–Ω–∏—Ö –±—ñ—Ç
    """
    # –û–±—á–∏—Å–ª—é—î–º–æ —Ä—ñ–∑–Ω–∏—Ü—é
    diff = p2 - p1

    # –ó–Ω–∞—Ö–æ–¥–∏–º–æ –¥—ñ–∞–ø–∞–∑–æ–Ω
    lower, upper, capacity = find_range(diff)

    # –ü—ñ–¥–≥–æ—Ç–æ–≤–∫–∞ –±—ñ—Ç—ñ–≤ –¥–ª—è –≤–±—É–¥–æ–≤—É–≤–∞–Ω–Ω—è
    if len(secret_bits) < capacity:
        # –î–æ–ø–æ–≤–Ω—é—î–º–æ –Ω—É–ª—è–º–∏ —è–∫—â–æ –Ω–µ–¥–æ—Å—Ç–∞—Ç–Ω—å–æ –±—ñ—Ç—ñ–≤
        secret_bits = secret_bits + '0' * (capacity - len(secret_bits))
    else:
        # –ë–µ—Ä–µ–º–æ —Ç—ñ–ª—å–∫–∏ –ø–æ—Ç—Ä—ñ–±–Ω—É –∫—ñ–ª—å–∫—ñ—Å—Ç—å
        secret_bits = secret_bits[:capacity]

    # –ö–æ–Ω–≤–µ—Ä—Ç—É—î–º–æ –±—ñ—Ç–∏ –≤ –¥–µ—Å—è—Ç–∫–æ–≤–µ —á–∏—Å–ª–æ
    secret_decimal = int(secret_bits, 2)

    # –û–±—á–∏—Å–ª—é—î–º–æ –Ω–æ–≤—É —Ä—ñ–∑–Ω–∏—Ü—é
    if diff >= 0:
        new_diff = lower + secret_decimal
    else:
        new_diff = -(lower + secret_decimal)

    # –û–±—á–∏—Å–ª—é—î–º–æ –º–æ–¥–∏—Ñ—ñ–∫–∞—Ü—ñ—é
    modification = new_diff - diff

    # –†–æ–∑–ø–æ–¥—ñ–ª—è—î–º–æ –º–æ–¥–∏—Ñ—ñ–∫–∞—Ü—ñ—é –º—ñ–∂ –ø—ñ–∫—Å–µ–ª—è–º–∏
    if abs(modification) % 2 == 0:
        # –ü–∞—Ä–Ω–∞ –º–æ–¥–∏—Ñ—ñ–∫–∞—Ü—ñ—è - —Ä—ñ–≤–Ω–æ–º—ñ—Ä–Ω–∏–π —Ä–æ–∑–ø–æ–¥—ñ–ª
        new_p1 = p1 - modification // 2
        new_p2 = p2 + modification // 2
    else:
        # –ù–µ–ø–∞—Ä–Ω–∞ –º–æ–¥–∏—Ñ—ñ–∫–∞—Ü—ñ—è - –Ω–µ—Ä—ñ–≤–Ω–æ–º—ñ—Ä–Ω–∏–π —Ä–æ–∑–ø–æ–¥—ñ–ª
        if modification > 0:
            new_p1 = p1 - modification // 2
            new_p2 = p2 + (modification // 2 + 1)
        else:
            new_p1 = p1 - (abs(modification) // 2 + 1)
            new_p2 = p2 + abs(modification) // 2

    # –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ –≥—Ä–∞–Ω–∏—Ü—ñ [0, 255]
    new_p1 = max(0, min(255, new_p1))
    new_p2 = max(0, min(255, new_p2))

    return new_p1, new_p2, capacity

def pvd_embed(image, message):
    """
    –í–±—É–¥–æ–≤—É—î –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—é—á–∏ PVD –º–µ—Ç–æ–¥

    Parameters:
    -----------
    image : numpy array - –æ—Ä–∏–≥—ñ–Ω–∞–ª—å–Ω–µ –∑–æ–±—Ä–∞–∂–µ–Ω–Ω—è
    message : str - –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è –¥–ª—è –≤–±—É–¥–æ–≤—É–≤–∞–Ω–Ω—è

    Returns:
    --------
    stego : numpy array - —Å—Ç–µ–≥–æ-–∑–æ–±—Ä–∞–∂–µ–Ω–Ω—è
    """
    # –ö–æ–ø—ñ—é—î–º–æ –∑–æ–±—Ä–∞–∂–µ–Ω–Ω—è
    stego = image.copy()

    # –ü—Ä–∞—Ü—é—î–º–æ –∑ grayscale –∞–±–æ —Å–∏–Ω—ñ–º –∫–∞–Ω–∞–ª–æ–º
    if len(stego.shape) == 3:
        channel = stego[:, :, 0].copy()
    else:
        channel = stego.copy()

    height, width = channel.shape

    # –ö–æ–Ω–≤–µ—Ä—Ç—É—î–º–æ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è
    binary_message = text_to_binary(message)
    length_binary = format(len(binary_message), '032b')
    binary_message = length_binary + binary_message

    # –ê–Ω–∞–ª—ñ–∑ —î–º–Ω–æ—Å—Ç—ñ
    total_capacity = 0
    for y in range(height):
        for x in range(0, width - 1, 2):
            p1 = int(channel[y, x])
            p2 = int(channel[y, x + 1])
            _, _, block_capacity = find_range(abs(p2 - p1))
            total_capacity += block_capacity

    print(f"–ê–Ω–∞–ª—ñ–∑ PVD:")
    print(f"  –ö—ñ–ª—å–∫—ñ—Å—Ç—å –±–ª–æ–∫—ñ–≤: {(height * width) // 2}")
    print(f"  –ó–∞–≥–∞–ª—å–Ω–∞ —î–º–Ω—ñ—Å—Ç—å: {total_capacity} –±—ñ—Ç")
    print(f"  –ù–µ–æ–±—Ö—ñ–¥–Ω–æ –¥–ª—è –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è: {len(binary_message)} –±—ñ—Ç")

    if len(binary_message) > total_capacity:
        raise ValueError(f"–ü–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è –∑–∞–Ω–∞–¥—Ç–æ –≤–µ–ª–∏–∫–µ!")

    # –í–±—É–¥–æ–≤—É–≤–∞–Ω–Ω—è –ø–æ –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω–∏—Ö –±–ª–æ–∫–∞—Ö
    message_idx = 0
    blocks_modified = 0
    bits_embedded = 0

    for y in range(height):
        for x in range(0, width - 1, 2):
            if message_idx >= len(binary_message):
                break

            p1 = int(channel[y, x])
            p2 = int(channel[y, x + 1])

            # –ó–Ω–∞—Ö–æ–¥–∏–º–æ —î–º–Ω—ñ—Å—Ç—å –±–ª–æ–∫—É
            _, _, block_capacity = find_range(abs(p2 - p1))

            # –ë–µ—Ä–µ–º–æ –ø–æ—Ç—Ä—ñ–±–Ω—É –∫—ñ–ª—å–∫—ñ—Å—Ç—å –±—ñ—Ç
            end_idx = min(message_idx + block_capacity, len(binary_message))
            secret_bits = binary_message[message_idx:end_idx]

            if secret_bits:
                # –í–±—É–¥–æ–≤—É—î–º–æ
                new_p1, new_p2, embedded = embed_block_pvd(p1, p2, secret_bits)
                channel[y, x] = new_p1
                channel[y, x + 1] = new_p2

                message_idx = end_idx
                blocks_modified += 1
                bits_embedded += len(secret_bits)

    # –ü–æ–≤–µ—Ä—Ç–∞—î–º–æ –∫–∞–Ω–∞–ª –Ω–∞–∑–∞–¥
    if len(stego.shape) == 3:
        stego[:, :, 0] = channel
    else:
        stego = channel

    print(f"\n–†–µ–∑—É–ª—å—Ç–∞—Ç–∏ PVD –≤–±—É–¥–æ–≤—É–≤–∞–Ω–Ω—è:")
    print(f"  –í–±—É–¥–æ–≤–∞–Ω–æ {bits_embedded} –±—ñ—Ç")
    print(f"  –ú–æ–¥–∏—Ñ—ñ–∫–æ–≤–∞–Ω–æ {blocks_modified} –±–ª–æ–∫—ñ–≤")
    print(f"  PSNR: {calculate_psnr(image, stego):.2f} dB")

    return stego

def extract_block_pvd(p1, p2):
    """
    –í–∏—Ç—è–≥—É—î –±—ñ—Ç–∏ –∑ –æ–¥–Ω–æ–≥–æ –±–ª–æ–∫—É PVD

    Returns:
    --------
    secret_bits : str - –≤–∏—Ç—è–≥–Ω—É—Ç—ñ –±—ñ—Ç–∏
    """
    # –û–±—á–∏—Å–ª—é—î–º–æ —Ä—ñ–∑–Ω–∏—Ü—é
    diff = abs(p2 - p1)

    # –ó–Ω–∞—Ö–æ–¥–∏–º–æ –¥—ñ–∞–ø–∞–∑–æ–Ω
    lower, upper, capacity = find_range(diff)

    # –í–∏—Ç—è–≥—É—î–º–æ —Å–µ–∫—Ä–µ—Ç–Ω–µ –∑–Ω–∞—á–µ–Ω–Ω—è
    secret_value = diff - lower

    # –ö–æ–Ω–≤–µ—Ä—Ç—É—î–º–æ –≤ –±—ñ–Ω–∞—Ä–Ω–∏–π —Ñ–æ—Ä–º–∞—Ç
    secret_bits = format(secret_value, f'0{capacity}b')

    return secret_bits

def pvd_extract(stego_image):
    """
    –í–∏—Ç—è–≥—É—î –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è –∑ PVD —Å—Ç–µ–≥–æ-–∑–æ–±—Ä–∞–∂–µ–Ω–Ω—è

    Parameters:
    -----------
    stego_image : numpy array - —Å—Ç–µ–≥–æ-–∑–æ–±—Ä–∞–∂–µ–Ω–Ω—è

    Returns:
    --------
    message : str - –≤–∏—Ç—è–≥–Ω—É—Ç–µ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è
    """
    # –ü—Ä–∞—Ü—é—î–º–æ –∑ grayscale –∞–±–æ —Å–∏–Ω—ñ–º –∫–∞–Ω–∞–ª–æ–º
    if len(stego_image.shape) == 3:
        channel = stego_image[:, :, 0]
    else:
        channel = stego_image

    height, width = channel.shape

    # –í–∏—Ç—è–≥—É–≤–∞–Ω–Ω—è –±—ñ—Ç—ñ–≤
    binary_message = ''

    for y in range(height):
        for x in range(0, width - 1, 2):
            p1 = int(channel[y, x])
            p2 = int(channel[y, x + 1])

            # –í–∏—Ç—è–≥—É—î–º–æ –±—ñ—Ç–∏ –∑ –±–ª–æ–∫—É
            block_bits = extract_block_pvd(p1, p2)
            binary_message += block_bits

    # –í–∏—Ç—è–≥—É—î–º–æ –¥–æ–≤–∂–∏–Ω—É
    if len(binary_message) < 32:
        return ""

    length_binary = binary_message[:32]
    length = int(length_binary, 2)

    # –í–∏—Ç—è–≥—É—î–º–æ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è
    if length > 0 and 32 + length <= len(binary_message):
        message_binary = binary_message[32:32+length]
        return binary_to_text(message_binary)

    return ""

# –¢–µ—Å—Ç—É–≤–∞–Ω–Ω—è PVD
def test_pvd():
    """–¢–µ—Å—Ç—É—î PVD —Å—Ç–µ–≥–∞–Ω–æ–≥—Ä–∞—Ñ—ñ—é"""

    # –°—Ç–≤–æ—Ä—é—î–º–æ —Ç–µ—Å—Ç–æ–≤–µ –∑–æ–±—Ä–∞–∂–µ–Ω–Ω—è –∑ –≥—Ä–∞–¥—ñ—î–Ω—Ç–æ–º
    test_image = np.zeros((256, 256), dtype=np.uint8)

    # –î–æ–¥–∞—î–º–æ –≥—Ä–∞–¥—ñ—î–Ω—Ç –¥–ª—è —Ä—ñ–∑–Ω–∏—Ö —Ä—ñ–∑–Ω–∏—Ü—å
    for i in range(256):
        test_image[i, :] = i

    # –î–æ–¥–∞—î–º–æ —à—É–º –¥–ª—è –∑–±—ñ–ª—å—à–µ–Ω–Ω—è —Ä—ñ–∑–Ω–∏—Ü—å
    noise = np.random.randint(-20, 20, (256, 256))
    test_image = np.clip(test_image + noise, 0, 255).astype(np.uint8)

    # –¢–µ—Å—Ç–æ–≤–µ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è
    message = "PVD –º–µ—Ç–æ–¥: –ø—Ä–∏—Ö–æ–≤—É–≤–∞–Ω–Ω—è –≤ —Ä—ñ–∑–Ω–∏—Ü—è—Ö –ø—ñ–∫—Å–µ–ª—ñ–≤!"

    print("="*60)
    print("–¢–ï–°–¢–£–í–ê–ù–ù–Ø PVD –ú–ï–¢–û–î–£")
    print("="*60)

    # –í–±—É–¥–æ–≤—É–≤–∞–Ω–Ω—è
    print("\n1. –í–±—É–¥–æ–≤—É–≤–∞–Ω–Ω—è –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è...")
    print(f"   –ü–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è: '{message}'")
    print(f"   –î–æ–≤–∂–∏–Ω–∞: {len(message)} —Å–∏–º–≤–æ–ª—ñ–≤ ({len(text_to_binary(message))} –±—ñ—Ç)")

    stego_pvd = pvd_embed(test_image, message)

    # –í–∏—Ç—è–≥—É–≤–∞–Ω–Ω—è
    print("\n2. –í–∏—Ç—è–≥—É–≤–∞–Ω–Ω—è –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è...")
    extracted_pvd = pvd_extract(stego_pvd)

    print(f"   –í–∏—Ç—è–≥–Ω—É—Ç–µ: '{extracted_pvd}'")
    print(f"   –£—Å–ø—ñ—à–Ω—ñ—Å—Ç—å: {'‚úÖ –ü–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è —Å–ø—ñ–≤–ø–∞–¥–∞—î!' if message == extracted_pvd else '‚ùå –ü–æ–º–∏–ª–∫–∞ –≤–∏—Ç—è–≥—É–≤–∞–Ω–Ω—è'}")

    # –í—ñ–∑—É–∞–ª—ñ–∑–∞—Ü—ñ—è
    fig, axes = plt.subplots(2, 3, figsize=(15, 10))

    # –û—Ä–∏–≥—ñ–Ω–∞–ª
    axes[0, 0].imshow(test_image, cmap='gray')
    axes[0, 0].set_title('–û—Ä–∏–≥—ñ–Ω–∞–ª—å–Ω–µ –∑–æ–±—Ä–∞–∂–µ–Ω–Ω—è')
    axes[0, 0].axis('off')

    # –°—Ç–µ–≥–æ
    axes[0, 1].imshow(stego_pvd, cmap='gray')
    axes[0, 1].set_title(f'PVD –°—Ç–µ–≥–æ\n(PSNR: {calculate_psnr(test_image, stego_pvd):.2f} dB)')
    axes[0, 1].axis('off')

    # –†—ñ–∑–Ω–∏—Ü—è
    diff_pvd = np.abs(test_image.astype(int) - stego_pvd.astype(int))
    axes[0, 2].imshow(diff_pvd * 20, cmap='hot')
    axes[0, 2].set_title('–†—ñ–∑–Ω–∏—Ü—è (√ó20)')
    axes[0, 2].axis('off')

    # –ì—ñ—Å—Ç–æ–≥—Ä–∞–º–∞ —Ä—ñ–∑–Ω–∏—Ü—å –ø—ñ–∫—Å–µ–ª—ñ–≤
    differences = []
    for y in range(test_image.shape[0]):
        for x in range(0, test_image.shape[1] - 1, 2):
            diff = abs(int(test_image[y, x]) - int(test_image[y, x + 1]))
            differences.append(diff)

    axes[1, 0].hist(differences, bins=50, alpha=0.7, label='–û—Ä–∏–≥—ñ–Ω–∞–ª')

    differences_stego = []
    for y in range(stego_pvd.shape[0]):
        for x in range(0, stego_pvd.shape[1] - 1, 2):
            diff = abs(int(stego_pvd[y, x]) - int(stego_pvd[y, x + 1]))
            differences_stego.append(diff)

    axes[1, 0].hist(differences_stego, bins=50, alpha=0.7, label='–°—Ç–µ–≥–æ')
    axes[1, 0].set_title('–†–æ–∑–ø–æ–¥—ñ–ª —Ä—ñ–∑–Ω–∏—Ü—å –ø—ñ–∫—Å–µ–ª—ñ–≤')
    axes[1, 0].set_xlabel('–†—ñ–∑–Ω–∏—Ü—è')
    axes[1, 0].set_ylabel('–ß–∞—Å—Ç–æ—Ç–∞')
    axes[1, 0].legend()

    # –ö–∞—Ä—Ç–∞ —î–º–Ω–æ—Å—Ç—ñ –±–ª–æ–∫—ñ–≤
    capacity_map = np.zeros((test_image.shape[0], test_image.shape[1] // 2))
    for y in range(test_image.shape[0]):
        for x in range(0, test_image.shape[1] - 1, 2):
            diff = abs(int(test_image[y, x]) - int(test_image[y, x + 1]))
            _, _, cap = find_range(diff)
            capacity_map[y, x // 2] = cap

    im = axes[1, 1].imshow(capacity_map, cmap='viridis', vmin=3, vmax=7)
    axes[1, 1].set_title('–ö–∞—Ä—Ç–∞ —î–º–Ω–æ—Å—Ç—ñ –±–ª–æ–∫—ñ–≤')
    axes[1, 1].axis('off')
    plt.colorbar(im, ax=axes[1, 1], label='–ë—ñ—Ç –Ω–∞ –±–ª–æ–∫')

    # –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ —î–º–Ω–æ—Å—Ç—ñ
    unique, counts = np.unique(capacity_map.flatten(), return_counts=True)
    axes[1, 2].bar(unique, counts, color='skyblue')
    axes[1, 2].set_title('–†–æ–∑–ø–æ–¥—ñ–ª —î–º–Ω–æ—Å—Ç—ñ –±–ª–æ–∫—ñ–≤')
    axes[1, 2].set_xlabel('–Ñ–º–Ω—ñ—Å—Ç—å (–±—ñ—Ç)')
    axes[1, 2].set_ylabel('–ö—ñ–ª—å–∫—ñ—Å—Ç—å –±–ª–æ–∫—ñ–≤')
    axes[1, 2].set_xticks(unique)

    plt.tight_layout()
    plt.show()

# –ó–∞–ø—É—Å–∫ —Ç–µ—Å—Ç—É
test_pvd()</code></pre>
        </div>

        <!-- –ó–∞–≤–¥–∞–Ω–Ω—è 5 -->
        <div class="task-box">
            <h3><span class="step-number">5</span>–ü–æ—Ä—ñ–≤–Ω—è–ª—å–Ω–∏–π –∞–Ω–∞–ª—ñ–∑ –º–µ—Ç–æ–¥—ñ–≤</h3>

            <h4>–ö–æ–º–ø–ª–µ–∫—Å–Ω–µ –ø–æ—Ä—ñ–≤–Ω—è–Ω–Ω—è –≤—Å—ñ—Ö –º–µ—Ç–æ–¥—ñ–≤:</h4>
            <pre class="python"><code>def classic_lsb_embed(image, message):
    """–ö–ª–∞—Å–∏—á–Ω–∏–π LSB –¥–ª—è –ø–æ—Ä—ñ–≤–Ω—è–Ω–Ω—è"""
    stego = image.copy()
    binary_msg = text_to_binary(message)
    length_binary = format(len(binary_msg), '032b')
    binary_msg = length_binary + binary_msg

    idx = 0
    height, width = image.shape[:2]

    for y in range(height):
        for x in range(width):
            if idx < len(binary_msg):
                if len(image.shape) == 3:
                    bit = int(binary_msg[idx])
                    stego[y, x, 0] = (stego[y, x, 0] & 0xFE) | bit
                else:
                    bit = int(binary_msg[idx])
                    stego[y, x] = (stego[y, x] & 0xFE) | bit
                idx += 1
            else:
                break

    return stego

def compare_methods(image, message):
    """
    –ü–æ—Ä—ñ–≤–Ω—é—î —Ä—ñ–∑–Ω—ñ –º–µ—Ç–æ–¥–∏ —Å—Ç–µ–≥–∞–Ω–æ–≥—Ä–∞—Ñ—ñ—ó

    Returns:
    --------
    results : dict - —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∏ –ø–æ—Ä—ñ–≤–Ω—è–Ω–Ω—è
    """
    results = {}

    print("="*60)
    print("–ü–û–†–Ü–í–ù–Ø–õ–¨–ù–ò–ô –ê–ù–ê–õ–Ü–ó –ú–ï–¢–û–î–Ü–í –°–¢–ï–ì–ê–ù–û–ì–†–ê–§–Ü–á")
    print("="*60)
    print(f"\n–¢–µ—Å—Ç–æ–≤–µ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è: '{message}'")
    print(f"–î–æ–≤–∂–∏–Ω–∞: {len(message)} —Å–∏–º–≤–æ–ª—ñ–≤ ({len(text_to_binary(message))} –±—ñ—Ç)")
    print("\n" + "-"*60)

    # 1. –ö–ª–∞—Å–∏—á–Ω–∏–π LSB
    print("\n1. –ö–õ–ê–°–ò–ß–ù–ò–ô LSB:")
    start_time = time.time()
    stego_classic = classic_lsb_embed(image, message)
    time_classic = time.time() - start_time

    psnr_classic = calculate_psnr(image, stego_classic)
    ssim_classic = calculate_ssim(image, stego_classic)

    results['Classic LSB'] = {
        'stego': stego_classic,
        'psnr': psnr_classic,
        'ssim': ssim_classic,
        'time': time_classic * 1000,  # –≤ –º—ñ–ª—ñ—Å–µ–∫—É–Ω–¥–∞—Ö
        'capacity': image.shape[0] * image.shape[1]  # –≤—Å—ñ –ø—ñ–∫—Å–µ–ª—ñ
    }

    print(f"   PSNR: {psnr_classic:.2f} dB")
    print(f"   SSIM: {ssim_classic:.4f}")
    print(f"   –ß–∞—Å: {time_classic*1000:.2f} –º—Å")
    print(f"   –Ñ–º–Ω—ñ—Å—Ç—å: {results['Classic LSB']['capacity']} –±—ñ—Ç")

    # 2. Edge-based LSB
    print("\n2. EDGE-BASED LSB:")
    start_time = time.time()
    try:
        stego_edge, pixel_classes = edge_based_embed(image, message, edge_threshold=50)
        time_edge = time.time() - start_time

        psnr_edge = calculate_psnr(image, stego_edge)
        ssim_edge = calculate_ssim(image, stego_edge)

        capacity_edge = np.sum(pixel_classes == 1) + np.sum(pixel_classes == 2) * 2

        results['Edge-based LSB'] = {
            'stego': stego_edge,
            'psnr': psnr_edge,
            'ssim': ssim_edge,
            'time': time_edge * 1000,
            'capacity': capacity_edge,
            'pixel_classes': pixel_classes
        }

        print(f"   PSNR: {psnr_edge:.2f} dB")
        print(f"   SSIM: {ssim_edge:.4f}")
        print(f"   –ß–∞—Å: {time_edge*1000:.2f} –º—Å")
        print(f"   –Ñ–º–Ω—ñ—Å—Ç—å: {capacity_edge} –±—ñ—Ç")
    except Exception as e:
        print(f"   –ü–æ–º–∏–ª–∫–∞: {str(e)}")
        results['Edge-based LSB'] = None

    # 3. PVD (–¥–ª—è grayscale)
    print("\n3. PVD –ú–ï–¢–û–î:")
    if len(image.shape) == 3:
        gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
    else:
        gray = image.copy()

    start_time = time.time()
    try:
        stego_pvd = pvd_embed(gray, message)
        time_pvd = time.time() - start_time

        psnr_pvd = calculate_psnr(gray, stego_pvd)
        ssim_pvd = calculate_ssim(gray, stego_pvd)

        # –û–±—á–∏—Å–ª—é—î–º–æ —î–º–Ω—ñ—Å—Ç—å PVD
        capacity_pvd = 0
        height, width = gray.shape
        for y in range(height):
            for x in range(0, width - 1, 2):
                p1 = gray[y, x]
                p2 = gray[y, x + 1]
                _, _, cap = find_range(abs(p2 - p1))
                capacity_pvd += cap

        results['PVD'] = {
            'stego': stego_pvd,
            'psnr': psnr_pvd,
            'ssim': ssim_pvd,
            'time': time_pvd * 1000,
            'capacity': capacity_pvd
        }

        print(f"   PSNR: {psnr_pvd:.2f} dB")
        print(f"   SSIM: {ssim_pvd:.4f}")
        print(f"   –ß–∞—Å: {time_pvd*1000:.2f} –º—Å")
        print(f"   –Ñ–º–Ω—ñ—Å—Ç—å: {capacity_pvd} –±—ñ—Ç")
    except Exception as e:
        print(f"   –ü–æ–º–∏–ª–∫–∞: {str(e)}")
        results['PVD'] = None

    print("\n" + "="*60)

    return results

def visualize_comparison(results, original_image):
    """–í—ñ–∑—É–∞–ª—ñ–∑–∞—Ü—ñ—è —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ñ–≤ –ø–æ—Ä—ñ–≤–Ω—è–Ω–Ω—è"""

    # –ü—ñ–¥–≥–æ—Ç–æ–≤–∫–∞ –¥–∞–Ω–∏—Ö –¥–ª—è –≥—Ä–∞—Ñ—ñ–∫—ñ–≤
    methods = []
    psnr_values = []
    ssim_values = []
    time_values = []
    capacity_values = []

    for method, data in results.items():
        if data is not None:
            methods.append(method)
            psnr_values.append(data['psnr'])
            ssim_values.append(data['ssim'])
            time_values.append(data['time'])
            capacity_values.append(data['capacity'])

    # –°—Ç–≤–æ—Ä–µ–Ω–Ω—è –≤—ñ–∑—É–∞–ª—ñ–∑–∞—Ü—ñ—ó
    fig = plt.figure(figsize=(16, 12))

    # 1. PSNR –ø–æ—Ä—ñ–≤–Ω—è–Ω–Ω—è
    ax1 = plt.subplot(3, 3, 1)
    bars1 = ax1.bar(methods, psnr_values, color=['blue', 'green', 'red'])
    ax1.set_title('PSNR (Peak Signal-to-Noise Ratio)')
    ax1.set_ylabel('PSNR (dB)')
    ax1.set_ylim([0, max(psnr_values) * 1.2])
    for bar, value in zip(bars1, psnr_values):
        ax1.text(bar.get_x() + bar.get_width()/2, bar.get_height() + 1,
                f'{value:.1f}', ha='center')

    # 2. SSIM –ø–æ—Ä—ñ–≤–Ω—è–Ω–Ω—è
    ax2 = plt.subplot(3, 3, 2)
    bars2 = ax2.bar(methods, ssim_values, color=['blue', 'green', 'red'])
    ax2.set_title('SSIM (Structural Similarity)')
    ax2.set_ylabel('SSIM')
    ax2.set_ylim([0, 1.1])
    for bar, value in zip(bars2, ssim_values):
        ax2.text(bar.get_x() + bar.get_width()/2, bar.get_height() + 0.01,
                f'{value:.4f}', ha='center')

    # 3. –ß–∞—Å –≤–∏–∫–æ–Ω–∞–Ω–Ω—è
    ax3 = plt.subplot(3, 3, 3)
    bars3 = ax3.bar(methods, time_values, color=['blue', 'green', 'red'])
    ax3.set_title('–ß–∞—Å –≤–∏–∫–æ–Ω–∞–Ω–Ω—è')
    ax3.set_ylabel('–ß–∞—Å (–º—Å)')
    for bar, value in zip(bars3, time_values):
        ax3.text(bar.get_x() + bar.get_width()/2, bar.get_height() + 0.5,
                f'{value:.1f}', ha='center')

    # 4. –Ñ–º–Ω—ñ—Å—Ç—å
    ax4 = plt.subplot(3, 3, 4)
    bars4 = ax4.bar(methods, capacity_values, color=['blue', 'green', 'red'])
    ax4.set_title('–î–æ—Å—Ç—É–ø–Ω–∞ —î–º–Ω—ñ—Å—Ç—å')
    ax4.set_ylabel('–Ñ–º–Ω—ñ—Å—Ç—å (–±—ñ—Ç)')
    for bar, value in zip(bars4, capacity_values):
        ax4.text(bar.get_x() + bar.get_width()/2, bar.get_height() + 1000,
                f'{value}', ha='center', rotation=0)

    # 5-7. –í—ñ–∑—É–∞–ª—å–Ω–µ –ø–æ—Ä—ñ–≤–Ω—è–Ω–Ω—è —Å—Ç–µ–≥–æ-–∑–æ–±—Ä–∞–∂–µ–Ω—å
    for idx, (method, data) in enumerate(results.items()):
        if data is not None:
            ax = plt.subplot(3, 3, 5 + idx)
            if len(data['stego'].shape) == 3:
                ax.imshow(cv2.cvtColor(data['stego'], cv2.COLOR_BGR2RGB))
            else:
                ax.imshow(data['stego'], cmap='gray')
            ax.set_title(f'{method}\n(PSNR: {data["psnr"]:.1f} dB)')
            ax.axis('off')

    # 8. –†–∞–¥–∞—Ä–Ω–∞ –¥—ñ–∞–≥—Ä–∞–º–∞ –ø–æ—Ä—ñ–≤–Ω—è–Ω–Ω—è
    ax8 = plt.subplot(3, 3, 8, projection='polar')

    categories = ['PSNR', 'SSIM', 'Speed', 'Capacity']
    angles = np.linspace(0, 2 * np.pi, len(categories), endpoint=False).tolist()
    angles += angles[:1]  # –ó–∞–º–∫–Ω—É—Ç–∏ –¥—ñ–∞–≥—Ä–∞–º—É

    for idx, method in enumerate(methods):
        # –ù–æ—Ä–º–∞–ª—ñ–∑–∞—Ü—ñ—è –∑–Ω–∞—á–µ–Ω—å –¥–æ [0, 1]
        values = [
            psnr_values[idx] / max(psnr_values),
            ssim_values[idx],
            1 - (time_values[idx] / max(time_values)),  # –Ü–Ω–≤–µ—Ä—Ç—É—î–º–æ —á–∞—Å
            capacity_values[idx] / max(capacity_values)
        ]
        values += values[:1]  # –ó–∞–º–∫–Ω—É—Ç–∏ –¥—ñ–∞–≥—Ä–∞–º—É

        ax8.plot(angles, values, 'o-', linewidth=2, label=method)
        ax8.fill(angles, values, alpha=0.25)

    ax8.set_xticks(angles[:-1])
    ax8.set_xticklabels(categories)
    ax8.set_ylim(0, 1)
    ax8.set_title('–ö–æ–º–ø–ª–µ–∫—Å–Ω–µ –ø–æ—Ä—ñ–≤–Ω—è–Ω–Ω—è')
    ax8.legend(loc='upper right', bbox_to_anchor=(1.3, 1.1))
    ax8.grid(True)

    # 9. –¢–∞–±–ª–∏—Ü—è —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ñ–≤
    ax9 = plt.subplot(3, 3, 9)
    ax9.axis('tight')
    ax9.axis('off')

    table_data = [['–ú–µ—Ç–æ–¥', 'PSNR', 'SSIM', '–ß–∞—Å (–º—Å)', '–Ñ–º–Ω—ñ—Å—Ç—å']]
    for idx, method in enumerate(methods):
        table_data.append([
            method,
            f'{psnr_values[idx]:.2f}',
            f'{ssim_values[idx]:.4f}',
            f'{time_values[idx]:.2f}',
            f'{capacity_values[idx]}'
        ])

    table = ax9.table(cellText=table_data, loc='center', cellLoc='center')
    table.auto_set_font_size(False)
    table.set_fontsize(9)
    table.scale(1, 1.5)

    # –°—Ç–∏–ª—å –∑–∞–≥–æ–ª–æ–≤–∫—ñ–≤ —Ç–∞–±–ª–∏—Ü—ñ
    for i in range(len(table_data[0])):
        table[(0, i)].set_facecolor('#40466e')
        table[(0, i)].set_text_props(weight='bold', color='white')

    # –ö–æ–ª—å–æ—Ä–æ–≤–µ –∫–æ–¥—É–≤–∞–Ω–Ω—è —Ä—è–¥–∫—ñ–≤
    colors = ['#e6f2ff', '#ffe6e6', '#e6ffe6']
    for i in range(1, len(table_data)):
        for j in range(len(table_data[0])):
            table[(i, j)].set_facecolor(colors[(i-1) % 3])

    plt.suptitle('–ü–æ—Ä—ñ–≤–Ω—è–ª—å–Ω–∏–π –∞–Ω–∞–ª—ñ–∑ –º–µ—Ç–æ–¥—ñ–≤ —Å—Ç–µ–≥–∞–Ω–æ–≥—Ä–∞—Ñ—ñ—ó', fontsize=16, fontweight='bold')
    plt.tight_layout()
    plt.show()

# –û—Å–Ω–æ–≤–Ω–∞ —Ñ—É–Ω–∫—Ü—ñ—è —Ç–µ—Å—Ç—É–≤–∞–Ω–Ω—è
def run_comprehensive_test():
    """–ó–∞–ø—É—Å–∫–∞—î –∫–æ–º–ø–ª–µ–∫—Å–Ω–µ —Ç–µ—Å—Ç—É–≤–∞–Ω–Ω—è –≤—Å—ñ—Ö –º–µ—Ç–æ–¥—ñ–≤"""

    # –°—Ç–≤–æ—Ä—é—î–º–æ —Ä–µ–∞–ª—ñ—Å—Ç–∏—á–Ω–µ —Ç–µ—Å—Ç–æ–≤–µ –∑–æ–±—Ä–∞–∂–µ–Ω–Ω—è
    print("–°—Ç–≤–æ—Ä–µ–Ω–Ω—è —Ç–µ—Å—Ç–æ–≤–æ–≥–æ –∑–æ–±—Ä–∞–∂–µ–Ω–Ω—è...")
    test_image = np.zeros((400, 400, 3), dtype=np.uint8)

    # –î–æ–¥–∞—î–º–æ —Ä—ñ–∑–Ω—ñ —Ç–µ–∫—Å—Ç—É—Ä–∏ —Ç–∞ –µ–ª–µ–º–µ–Ω—Ç–∏
    # 1. –ì–ª–∞–¥–∫–∞ –æ–±–ª–∞—Å—Ç—å (–Ω–µ–±–æ)
    test_image[:100, :] = [135, 206, 235]  # Sky blue

    # 2. –ì—Ä–∞–¥—ñ—î–Ω—Ç (–∑–∞—Ö—ñ–¥ —Å–æ–Ω—Ü—è)
    for i in range(100):
        color_r = int(255 - i * 1.2)
        color_g = int(150 - i * 0.5)
        color_b = int(100 + i * 0.5)
        test_image[100+i, :] = [color_b, color_g, color_r]

    # 3. –¢–µ–∫—Å—Ç—É—Ä–∞ (—Ç—Ä–∞–≤–∞)
    grass = np.random.randint(40, 80, (100, 400, 3))
    grass[:, :, 1] = np.random.randint(80, 120, (100, 400))  # –ë—ñ–ª—å—à–µ –∑–µ–ª–µ–Ω–æ–≥–æ
    test_image[200:300, :] = grass

    # 4. –û–±'—î–∫—Ç–∏ –∑ —á—ñ—Ç–∫–∏–º–∏ –∫—Ä–∞—è–º–∏
    cv2.rectangle(test_image, (50, 250), (150, 350), (139, 69, 19), -1)  # –ë—É–¥–∏–Ω–æ–∫
    cv2.rectangle(test_image, (70, 270), (90, 290), (255, 255, 255), -1)  # –í—ñ–∫–Ω–æ
    cv2.rectangle(test_image, (110, 270), (130, 290), (255, 255, 255), -1)  # –í—ñ–∫–Ω–æ
    cv2.rectangle(test_image, (90, 310), (110, 350), (101, 67, 33), -1)  # –î–≤–µ—Ä—ñ

    # –¢—Ä–∏–∫—É—Ç–Ω–∏–π –¥–∞—Ö
    pts = np.array([[50, 250], [100, 200], [150, 250]], np.int32)
    cv2.fillPoly(test_image, [pts], (178, 34, 34))

    # –°–æ–Ω—Ü–µ
    cv2.circle(test_image, (320, 80), 30, (255, 255, 0), -1)

    # –î–µ—Ä–µ–≤–æ
    cv2.circle(test_image, (280, 240), 40, (34, 139, 34), -1)  # –ö—Ä–æ–Ω–∞
    cv2.rectangle(test_image, (275, 240), (285, 300), (101, 67, 33), -1)  # –°—Ç–æ–≤–±—É—Ä

    # –î–æ–¥–∞—î–º–æ —à—É–º –¥–ª—è —Ä–µ–∞–ª—ñ—Å—Ç–∏—á–Ω–æ—Å—Ç—ñ
    noise = np.random.normal(0, 5, test_image.shape)
    test_image = np.clip(test_image + noise, 0, 255).astype(np.uint8)

    # –¢–µ—Å—Ç–æ–≤–µ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è
    test_message = "–¢–µ—Å—Ç –∞–¥–∞–ø—Ç–∏–≤–Ω–∏—Ö –º–µ—Ç–æ–¥—ñ–≤!"

    # –ó–∞–ø—É—Å–∫ –ø–æ—Ä—ñ–≤–Ω—è–Ω–Ω—è
    results = compare_methods(test_image, test_message)

    # –í—ñ–∑—É–∞–ª—ñ–∑–∞—Ü—ñ—è —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ñ–≤
    visualize_comparison(results, test_image)

    # –í–∏—Å–Ω–æ–≤–∫–∏
    print("\n" + "="*60)
    print("–í–ò–°–ù–û–í–ö–ò")
    print("="*60)

    # –ó–Ω–∞—Ö–æ–¥–∏–º–æ –Ω–∞–π–∫—Ä–∞—â—ñ –º–µ—Ç–æ–¥–∏ –∑–∞ —Ä—ñ–∑–Ω–∏–º–∏ –∫—Ä–∏—Ç–µ—Ä—ñ—è–º–∏
    best_psnr = max(results.items(), key=lambda x: x[1]['psnr'] if x[1] else 0)
    best_ssim = max(results.items(), key=lambda x: x[1]['ssim'] if x[1] else 0)
    best_speed = min(results.items(), key=lambda x: x[1]['time'] if x[1] else float('inf'))
    best_capacity = max(results.items(), key=lambda x: x[1]['capacity'] if x[1] else 0)

    print(f"\nüèÜ –ù–∞–π–∫—Ä–∞—â–∞ —è–∫—ñ—Å—Ç—å (PSNR): {best_psnr[0]} ({best_psnr[1]['psnr']:.2f} dB)")
    print(f"üèÜ –ù–∞–π–∫—Ä–∞—â–∞ —Å—Ç—Ä—É–∫—Ç—É—Ä–Ω–∞ —Å—Ö–æ–∂—ñ—Å—Ç—å (SSIM): {best_ssim[0]} ({best_ssim[1]['ssim']:.4f})")
    print(f"üèÜ –ù–∞–π—à–≤–∏–¥—à–∏–π –º–µ—Ç–æ–¥: {best_speed[0]} ({best_speed[1]['time']:.2f} –º—Å)")
    print(f"üèÜ –ù–∞–π–±—ñ–ª—å—à–∞ —î–º–Ω—ñ—Å—Ç—å: {best_capacity[0]} ({best_capacity[1]['capacity']} –±—ñ—Ç)")

    print("\n–†–ï–ö–û–ú–ï–ù–î–ê–¶–Ü–á:")
    print("‚Ä¢ –î–ª—è –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ—ó –Ω–µ–ø–æ–º—ñ—Ç–Ω–æ—Å—Ç—ñ: Edge-based LSB")
    print("‚Ä¢ –î–ª—è —à–≤–∏–¥–∫–æ–≥–æ –≤–±—É–¥–æ–≤—É–≤–∞–Ω–Ω—è: Classic LSB")
    print("‚Ä¢ –î–ª—è –±–∞–ª–∞–Ω—Å—É —è–∫–æ—Å—Ç—ñ —Ç–∞ —î–º–Ω–æ—Å—Ç—ñ: PVD")
    print("‚Ä¢ –î–ª—è —Å—Ç—ñ–π–∫–æ—Å—Ç—ñ –¥–æ —Å—Ç–µ–≥–æ–∞–Ω–∞–ª—ñ–∑—É: Edge-based LSB –∞–±–æ PVD")

# –ó–∞–ø—É—Å–∫ –∫–æ–º–ø–ª–µ–∫—Å–Ω–æ–≥–æ —Ç–µ—Å—Ç—É
run_comprehensive_test()</code></pre>
        </div>
    </section>

    <!-- –î–æ–¥–∞—Ç–∫–æ–≤—ñ –∑–∞–≤–¥–∞–Ω–Ω—è -->
    <section>
        <h2>üéØ –î–æ–¥–∞—Ç–∫–æ–≤—ñ –∑–∞–≤–¥–∞–Ω–Ω—è</h2>

        <div class="analysis-grid">
            <div class="analysis-card">
                <h4>üìä –ó–∞–≤–¥–∞–Ω–Ω—è 1: –û–ø—Ç–∏–º—ñ–∑–∞—Ü—ñ—è –ø–æ—Ä–æ–≥—ñ–≤</h4>
                <p>–î–æ—Å–ª—ñ–¥—ñ—Ç—å –≤–ø–ª–∏–≤ edge_threshold –Ω–∞ —î–º–Ω—ñ—Å—Ç—å —Ç–∞ —è–∫—ñ—Å—Ç—å Edge-based LSB. –ü–æ–±—É–¥—É–π—Ç–µ –≥—Ä–∞—Ñ—ñ–∫ –∑–∞–ª–µ–∂–Ω–æ—Å—Ç—ñ PSNR –≤—ñ–¥ –ø–æ—Ä–æ–≥—É (20, 40, 60, 80, 100).</p>
            </div>

            <div class="analysis-card">
                <h4>üîß –ó–∞–≤–¥–∞–Ω–Ω—è 2: –ì—ñ–±—Ä–∏–¥–Ω–∏–π –º–µ—Ç–æ–¥</h4>
                <p>–°—Ç–≤–æ—Ä—ñ—Ç—å –º–µ—Ç–æ–¥, —â–æ –∫–æ–º–±—ñ–Ω—É—î Edge-based LSB –¥–ª—è –∫—Ä–∞—ó–≤ —Ç–∞ PVD –¥–ª—è —Ç–µ–∫—Å—Ç—É—Ä–Ω–∏—Ö –æ–±–ª–∞—Å—Ç–µ–π. –ü–æ—Ä—ñ–≤–Ω—è–π—Ç–µ –∑ –æ–∫—Ä–µ–º–∏–º–∏ –º–µ—Ç–æ–¥–∞–º–∏.</p>
            </div>

            <div class="analysis-card">
                <h4>üñºÔ∏è –ó–∞–≤–¥–∞–Ω–Ω—è 3: –†—ñ–∑–Ω—ñ —Ç–∏–ø–∏ –∑–æ–±—Ä–∞–∂–µ–Ω—å</h4>
                <p>–ü—Ä–æ—Ç–µ—Å—Ç—É–π—Ç–µ –º–µ—Ç–æ–¥–∏ –Ω–∞ —Ä—ñ–∑–Ω–∏—Ö —Ç–∏–ø–∞—Ö –∑–æ–±—Ä–∞–∂–µ–Ω—å: –ø–æ—Ä—Ç—Ä–µ—Ç–∏, –ø–µ–π–∑–∞–∂—ñ, —Ç–µ–∫—Å—Ç. –í–∏–∑–Ω–∞—á—Ç–µ –æ–ø—Ç–∏–º–∞–ª—å–Ω–∏–π –º–µ—Ç–æ–¥ –¥–ª—è –∫–æ–∂–Ω–æ–≥–æ —Ç–∏–ø—É.</p>
            </div>

            <div class="analysis-card">
                <h4>üõ°Ô∏è –ó–∞–≤–¥–∞–Ω–Ω—è 4: –°—Ç—ñ–π–∫—ñ—Å—Ç—å –¥–æ –∞—Ç–∞–∫</h4>
                <p>–ü–µ—Ä–µ–≤—ñ—Ä—Ç–µ —Å—Ç—ñ–π–∫—ñ—Å—Ç—å –º–µ—Ç–æ–¥—ñ–≤ –¥–æ JPEG —Å—Ç–∏—Å–Ω–µ–Ω–Ω—è, –∑–º—ñ–Ω–∏ —Ä–æ–∑–º—ñ—Ä—É, –¥–æ–¥–∞–≤–∞–Ω–Ω—è —à—É–º—É. –Ø–∫–∏–π –º–µ—Ç–æ–¥ –Ω–∞–π—Å—Ç—ñ–π–∫—ñ—à–∏–π?</p>
            </div>
        </div>
    </section>

    <!-- –ó–≤—ñ—Ç –ø—Ä–æ –≤–∏–∫–æ–Ω–∞–Ω–Ω—è -->
    <section class="submission-section">
        <h2>üìù –ó–≤—ñ—Ç –ø—Ä–æ –≤–∏–∫–æ–Ω–∞–Ω–Ω—è —Ç–∞ —Ñ–æ—Ä–º–∞—Ç –∑–¥–∞—á—ñ</h2>

        <div class="submission-grid">
            <div class="submission-card">
                <h3>üìÅ –°—Ç—Ä—É–∫—Ç—É—Ä–∞ –∑–≤—ñ—Ç—É</h3>
                <ul>
                    <li>–¢–∏—Ç—É–ª—å–Ω–∞ —Å—Ç–æ—Ä—ñ–Ω–∫–∞ –∑ –¥–∞–Ω–∏–º–∏ —Å—Ç—É–¥–µ–Ω—Ç–∞</li>
                    <li>–ú–µ—Ç–∞ —Ç–∞ –∑–∞–≤–¥–∞–Ω–Ω—è —Ä–æ–±–æ—Ç–∏</li>
                    <li>–¢–µ–æ—Ä–µ—Ç–∏—á–Ω—ñ –æ—Å–Ω–æ–≤–∏ –∞–¥–∞–ø—Ç–∏–≤–Ω–∏—Ö –º–µ—Ç–æ–¥—ñ–≤</li>
                    <li>–û–ø–∏—Å —Ä–µ–∞–ª—ñ–∑–∞—Ü—ñ—ó –∫–æ–∂–Ω–æ–≥–æ –º–µ—Ç–æ–¥—É</li>
                    <li>–†–µ–∑—É–ª—å—Ç–∞—Ç–∏ –µ–∫—Å–ø–µ—Ä–∏–º–µ–Ω—Ç—ñ–≤ –∑ –≥—Ä–∞—Ñ—ñ–∫–∞–º–∏</li>
                    <li>–ü–æ—Ä—ñ–≤–Ω—è–ª—å–Ω–∏–π –∞–Ω–∞–ª—ñ–∑ –º–µ—Ç–æ–¥—ñ–≤</li>
                    <li>–í–∏—Å–Ω–æ–≤–∫–∏ —Ç–∞ —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü—ñ—ó</li>
                    <li>–î–æ–¥–∞—Ç–∫–∏ (–ø–æ–≤–Ω–∏–π –∫–æ–¥)</li>
                </ul>
            </div>

            <div class="submission-card">
                <h3>üíæ –§–∞–π–ª–∏ –¥–ª—è –∑–¥–∞—á—ñ</h3>
                <ul>
                    <li><span class="file-format">report.pdf</span> - –∑–≤—ñ—Ç —É —Ñ–æ—Ä–º–∞—Ç—ñ PDF</li>
                    <li><span class="file-format">edge_based_lsb.py</span> - —Ä–µ–∞–ª—ñ–∑–∞—Ü—ñ—è Edge-based</li>
                    <li><span class="file-format">pvd_method.py</span> - —Ä–µ–∞–ª—ñ–∑–∞—Ü—ñ—è PVD</li>
                    <li><span class="file-format">comparison.py</span> - –ø–æ—Ä—ñ–≤–Ω—è–ª—å–Ω–∏–π –∞–Ω–∞–ª—ñ–∑</li>
                    <li><span class="file-format">test_images/</span> - —Ç–µ—Å—Ç–æ–≤—ñ –∑–æ–±—Ä–∞–∂–µ–Ω–Ω—è</li>
                    <li><span class="file-format">results/</span> - —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∏ –µ–∫—Å–ø–µ—Ä–∏–º–µ–Ω—Ç—ñ–≤</li>
                </ul>
            </div>

            <div class="submission-card">
                <h3>‚ö° –í–∏–º–æ–≥–∏ –¥–æ –∫–æ–¥—É</h3>
                <ul>
                    <li>–ú–æ–¥—É–ª—å–Ω–∞ —Å—Ç—Ä—É–∫—Ç—É—Ä–∞ –∑ –æ–∫—Ä–µ–º–∏–º–∏ —Ñ—É–Ω–∫—Ü—ñ—è–º–∏</li>
                    <li>Docstrings –¥–ª—è –≤—Å—ñ—Ö —Ñ—É–Ω–∫—Ü—ñ–π</li>
                    <li>–û–±—Ä–æ–±–∫–∞ –≤–∏–Ω—è—Ç–∫—ñ–≤</li>
                    <li>–í–∞–ª—ñ–¥–∞—Ü—ñ—è –≤—Ö—ñ–¥–Ω–∏—Ö –¥–∞–Ω–∏—Ö</li>
                    <li>–ó–±–µ—Ä–µ–∂–µ–Ω–Ω—è —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ñ–≤ —É —Ñ–∞–π–ª–∏</li>
                </ul>
            </div>

            <div class="submission-card">
                <h3>üéØ –ö—Ä–∏—Ç–µ—Ä—ñ—ó –æ—Ü—ñ–Ω—é–≤–∞–Ω–Ω—è</h3>
                <ul>
                    <li>–ö–æ—Ä–µ–∫—Ç–Ω–∞ —Ä–µ–∞–ª—ñ–∑–∞—Ü—ñ—è –º–µ—Ç–æ–¥—ñ–≤ (40%)</li>
                    <li>–Ø–∫—ñ—Å—Ç—å –ø–æ—Ä—ñ–≤–Ω—è–ª—å–Ω–æ–≥–æ –∞–Ω–∞–ª—ñ–∑—É (20%)</li>
                    <li>–í—ñ–∑—É–∞–ª—ñ–∑–∞—Ü—ñ—è —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ñ–≤ (15%)</li>
                    <li>–î–æ–¥–∞—Ç–∫–æ–≤—ñ –∑–∞–≤–¥–∞–Ω–Ω—è (15%)</li>
                    <li>–û—Ñ–æ—Ä–º–ª–µ–Ω–Ω—è –∑–≤—ñ—Ç—É (10%)</li>
                </ul>
            </div>
        </div>

        <div class="deadline-warning">
            <strong>‚è∞ –¢–µ—Ä–º—ñ–Ω –∑–¥–∞—á—ñ:</strong> –ü—Ä–æ—Ç—è–≥–æ–º –¥–≤–æ—Ö —Ç–∏–∂–Ω—ñ–≤ –ø—ñ—Å–ª—è –ø—Ä–æ–≤–µ–¥–µ–Ω–Ω—è –ª–∞–±–æ—Ä–∞—Ç–æ—Ä–Ω–æ—ó —Ä–æ–±–æ—Ç–∏.
            –ó–∞—Ç—Ä–∏–º–∫–∞ –∑–¥–∞—á—ñ –∑–Ω–∏–∂—É—î –æ—Ü—ñ–Ω–∫—É –Ω–∞ 10% –∑–∞ –∫–æ–∂–µ–Ω —Ç–∏–∂–¥–µ–Ω—å.
        </div>
    </section>

    <!-- –í–∏—Å–Ω–æ–≤–∫–∏ -->
    <section class="result-box">
        <h2>üéì –í–∏—Å–Ω–æ–≤–∫–∏</h2>
        <p>
            –£ —Ü—ñ–π –ª–∞–±–æ—Ä–∞—Ç–æ—Ä–Ω—ñ–π —Ä–æ–±–æ—Ç—ñ –≤–∏ –æ—Å–≤–æ—ó–ª–∏ –∞–¥–∞–ø—Ç–∏–≤–Ω—ñ –º–µ—Ç–æ–¥–∏ LSB —Å—Ç–µ–≥–∞–Ω–æ–≥—Ä–∞—Ñ—ñ—ó:
        </p>
        <ul>
            <li><strong>Edge-based LSB</strong> - –∞–¥–∞–ø—Ç–∏–≤–Ω–µ –≤–±—É–¥–æ–≤—É–≤–∞–Ω–Ω—è –Ω–∞ –æ—Å–Ω–æ–≤—ñ –¥–µ—Ç–µ–∫—Ü—ñ—ó –∫—Ä–∞—ó–≤ –∑–∞–±–µ–∑–ø–µ—á—É—î –≤–∏—Å–æ–∫—É —è–∫—ñ—Å—Ç—å —Ç–∞ —Å—Ç—ñ–π–∫—ñ—Å—Ç—å –¥–æ –≤—ñ–∑—É–∞–ª—å–Ω–æ–≥–æ –≤–∏—è–≤–ª–µ–Ω–Ω—è</li>
            <li><strong>PVD –º–µ—Ç–æ–¥</strong> - –≤–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è —Ä—ñ–∑–Ω–∏—Ü—å –º—ñ–∂ –ø—ñ–∫—Å–µ–ª—è–º–∏ –¥–æ–∑–≤–æ–ª—è—î –¥–æ—Å—è–≥—Ç–∏ —Ö–æ—Ä–æ—à–æ–≥–æ –±–∞–ª–∞–Ω—Å—É –º—ñ–∂ —î–º–Ω—ñ—Å—Ç—é —Ç–∞ –Ω–µ–ø–æ–º—ñ—Ç–Ω—ñ—Å—Ç—é</li>
            <li><strong>–î–µ—Ç–µ–∫—Ü—ñ—è –∫—Ä–∞—ó–≤</strong> - –º–µ—Ç–æ–¥–∏ Sobel —Ç–∞ Canny —î –æ—Å–Ω–æ–≤–æ—é –¥–ª—è –≤–∏–∑–Ω–∞—á–µ–Ω–Ω—è –æ–±–ª–∞—Å—Ç–µ–π –≤–±—É–¥–æ–≤—É–≤–∞–Ω–Ω—è</li>
            <li><strong>–ü–æ—Ä—ñ–≤–Ω—è–ª—å–Ω–∏–π –∞–Ω–∞–ª—ñ–∑</strong> - –∫–æ–∂–µ–Ω –º–µ—Ç–æ–¥ –º–∞—î —Å–≤–æ—ó –ø–µ—Ä–µ–≤–∞–≥–∏ –∑–∞–ª–µ–∂–Ω–æ –≤—ñ–¥ –≤–∏–º–æ–≥ –¥–æ —Å–∏—Å—Ç–µ–º–∏</li>
        </ul>

        <div class="warning-box">
            <strong>‚ö†Ô∏è –ö–ª—é—á–æ–≤—ñ –≤–∏—Å–Ω–æ–≤–∫–∏:</strong>
            <ul>
                <li>–ê–¥–∞–ø—Ç–∏–≤–Ω—ñ –º–µ—Ç–æ–¥–∏ –∑–Ω–∞—á–Ω–æ —Å—Ç—ñ–π–∫—ñ—à—ñ –¥–æ —Å—Ç–µ–≥–∞–Ω–æ–∞–Ω–∞–ª—ñ–∑—É –ø–æ—Ä—ñ–≤–Ω—è–Ω–æ –∑ –∫–ª–∞—Å–∏—á–Ω–∏–º LSB</li>
                <li>–í–∏–±—ñ—Ä –º–µ—Ç–æ–¥—É –∑–∞–ª–µ–∂–∏—Ç—å –≤—ñ–¥ –ø—Ä—ñ–æ—Ä–∏—Ç–µ—Ç—ñ–≤: —è–∫—ñ—Å—Ç—å, —à–≤–∏–¥–∫—ñ—Å—Ç—å —á–∏ —î–º–Ω—ñ—Å—Ç—å</li>
                <li>–ö–æ–º–±—ñ–Ω—É–≤–∞–Ω–Ω—è –º–µ—Ç–æ–¥—ñ–≤ –º–æ–∂–µ –¥–∞—Ç–∏ –∫—Ä–∞—â—ñ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∏</li>
                <li>–ü—Ä–∞–≤–∏–ª—å–Ω–∏–π –≤–∏–±—ñ—Ä –ø–∞—Ä–∞–º–µ—Ç—Ä—ñ–≤ –∫—Ä–∏—Ç–∏—á–Ω–∏–π –¥–ª—è –µ—Ñ–µ–∫—Ç–∏–≤–Ω–æ—Å—Ç—ñ –º–µ—Ç–æ–¥—É</li>
            </ul>
        </div>
    </section>

    <!-- –ö–æ—Ä–∏—Å–Ω—ñ —Ä–µ—Å—É—Ä—Å–∏ -->
    <section>
        <h2>üìö –ö–æ—Ä–∏—Å–Ω—ñ —Ä–µ—Å—É—Ä—Å–∏</h2>

        <div class="resources-list">
            <ul>
                <li>üìñ <a href="#">Wu D.C., Tsai W.H. "A steganographic method for images by pixel-value differencing"</a></li>
                <li>üîß <a href="https://opencv.org/">OpenCV Documentation - Edge Detection</a></li>
                <li>üìä <a href="#">Yang C.H. "Adaptive data hiding in edge areas of images"</a></li>
                <li>üéì <a href="#">–ö—É—Ä—Å: "Advanced Steganography Techniques" (Stanford)</a></li>
                <li>üíª <a href="https://github.com/topics/adaptive-steganography">GitHub: Adaptive Steganography Projects</a></li>
            </ul>
        </div>
    </section>
</main>

<!-- Footer -->
<footer class="lab-footer">
    <div class="container">
        <p>&copy; 2024 –ö—É—Ä—Å "–û—Å–Ω–æ–≤–∏ —Å—Ç–µ–≥–∞–Ω–æ–≥—Ä–∞—Ñ—ñ—ó" | –ö–∞—Ñ–µ–¥—Ä–∞ –∫—ñ–±–µ—Ä–±–µ–∑–ø–µ–∫–∏</p>
    </div>
</footer>

<!-- JavaScript -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="../../assets/js/lab-functions.js"></script>
<script>
    // –Ü–Ω—ñ—Ü—ñ–∞–ª—ñ–∑–∞—Ü—ñ—è –ø—ñ–¥—Å–≤—ñ—Ç–∫–∏ –∫–æ–¥—É
    hljs.highlightAll();

    // –§—É–Ω–∫—Ü—ñ—è –ø–µ—Ä–µ–º–∏–∫–∞–Ω–Ω—è –≤–∫–ª–∞–¥–æ–∫ (—è–∫—â–æ –Ω–µ –≤–∏–∑–Ω–∞—á–µ–Ω–∞ –≤ lab-functions.js)
    if (typeof switchTab === 'undefined') {
        function switchTab(event, tabId) {
            // –ü—Ä–∏—Ö–æ–≤—É—î–º–æ –≤—Å—ñ –≤–∫–ª–∞–¥–∫–∏
            const tabContents = document.querySelectorAll('.tab-content');
            tabContents.forEach(tab => {
                tab.classList.remove('active');
            });

            // –î–µ–∞–∫—Ç–∏–≤—É—î–º–æ –≤—Å—ñ –∫–Ω–æ–ø–∫–∏
            const tabButtons = document.querySelectorAll('.tab-button');
            tabButtons.forEach(button => {
                button.classList.remove('active');
            });

            // –ü–æ–∫–∞–∑—É—î–º–æ –≤–∏–±—Ä–∞–Ω—É –≤–∫–ª–∞–¥–∫—É
            document.getElementById(tabId).classList.add('active');

            // –ê–∫—Ç–∏–≤—É—î–º–æ –Ω–∞—Ç–∏—Å–Ω—É—Ç—É –∫–Ω–æ–ø–∫—É
            event.currentTarget.classList.add('active');
        }
    }
</script>

</body>
</html>